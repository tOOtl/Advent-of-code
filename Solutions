# Advent of code

def DayOnePuzzleOne():
    instructions = """()(((()))(()()()((((()(((())(()(()((((((()(()(((())))((()(((()))((())(()((()()()()(((())(((((((())))()()(()(()(())(((((()()()((())(((((()()))))()(())(((())(())((((((())())))(()())))()))))()())()())((()()((()()()()(()((((((((()()())((()()(((((()(((())((())(()))()((((()((((((((())()((()())(())((()))())((((()())(((((((((((()()(((((()(()))())(((()(()))())((()(()())())())(()(((())(())())()()(()(()((()))((()))))((((()(((()))))((((()(()(()())())()(((()((((())((((()(((()()(())()()()())((()((((((()((()()))()((()))()(()()((())))(((()(((()))((()((()(()))(((()()(()(()()()))))()()(((()(((())())))))((()(((())()(()(())((()())))((((())))(()(()(()())()((()())))(((()((()(())()()((()((())(()()((())(())()))()))((()(())()))())(((((((()(()()(()(())())))))))(()((((((())((((())((())())(()()))))()(())(()())()())((())(()))))(()))(()((()))()(()((((((()()()()((((((((()(()(())((()()(()()))(())()())()((())))()))()())(((()))(())()(())()))()((()((()(()()())(())()()()((())())))((()()(()()((()(())()()())(((()(()()))))(())))(()(()())()))()()))))))()))))((((((())))())))(()(())())(()())))))(()))()))))))()((()))))()))))(()(()((()())())(()()))))(((())()))())())())(((()(()()))(())()(())(())((((((()()))))((()(()))))))(()))())(((()()(()))()())()()()())))))))))))))(())(()))(()))((()(())(()())(())())(()())(())()()(()())))()()()))(())())()))())())(())((())))))))(())))(())))))()))))((())(()(((()))))(()))()((()(())))(()())(((((()))()())()()))))()))))()))())(()(()()()))()))))))((()))))))))))()((()))((()(())((())()()(()()))()(()))))()()(()))()))(((())))(())()((())(())(()())()())())))))))())))()((())))()))(()))()()))(((((((()))())(()()))(()()(()))()(()((()())()))))))(((()()()())))(())()))()())(()()))()()))))))))(())))()))()()))))))()))()())))()(())(())))))()(())()()(()()))))())((()))))()))))(()(((((()))))))))())))())()(())()()))))(())))())()()())()()())()(()))))()))()))))))))())))((()))()))()))())))()())()()())))())))(()((())()((()))())))))())()(())((())))))))))))())()())(())())())(()))(()))()))())(()(())())()())()()(()))))(()(())))))))(())))())(())))))))())()()(())())())))(())))))()))()(()())()(()))())())))))()()(()))()))))())))))))))()))))()))))))())()())()()))))()())))())))))))))))()()))))()()(((()))()()(())()))))((()))))(()))(())())))(())()))))))(()))()))))(())())))))()))(()())))))))))))))())))))))))()((()())(()())))))))((()))))(())(())))()(()())())))())())(()()()())))()))))))())))))())()()())))))))))))()()(()))))()())()))((()())(()))))()(()))))))))))()())())(((())(()))))())()))()))()))))))()))))))(()))))()))))()(())))(())))(()))())()()(()()))()))(()()))))))))()))(()))())(()()(()(()())()()))()))))))))(())))))((()()(()))())())))))()))())(()())()()))())))()(()()()()))((())())))())()(()()))()))))))))(()))(())))()))))(()(()())(()))))()())())()))()()))())))))))))))())()))))))()))))))))())))))()))))())(()())))(())()))())())))))()()(()()())(()())))()()))(((()))(()()()))))()))))()))))((())))()((((((()()))))))())))))))))))(((()))))))))))))(())())))))())(()))))))(()))((()))())))()(()((()))()))()))))))))))())()))()(()()))))())))())(())()(()))()))())(()))()))))(()()))()()(())))))()))(())(()(()()))(()()())))))(((()))))))()))))))))))))(())(()))))()())())()()((()()))())))))(()))))())))))))()()()))))))))())))()(((()()))(())))))(((())())))))((()))()(()))(()))))(()())))(()))())))))()))))(())(())))()((()))(())())))()()))()))))))))()))(()()()(()()()(()))())(())()())(((()))(())))))))))(((()())))()()))))))))()(())(()))()((((())(())(()())))()))(((())()()()))((()))(()))())())))())))(()))())()())())(()(())())()()()(())))())(())))(())))(())()))()))(()((()))))))))())(()))))))())(()()))()()))()(()(()())))()()(()((()((((((()))(())))()()()))())()))((()()(()))())((()(()(()))(()()))))()())))()))()())))))))()()((()())(())))()))(()))(())(()))())(()(())))()()))))))(((()(((()()))()(()(())())((()()))()))()))()))()(()()()(()))((()())()(())))()()))(((())()()())(())()((()()()()(()(())(()()))()(((((()())))((())))))(()()()))))(((()(())))()))((()((()(())()(()((())))((()())()(()))(((()())()()(()))(())(((()((()())()((())()())(((()()))((()((())(()))(()())(()()()))((()))(())(()((()()())((()))(())))(())(())(())))(()())))(((((()(()(((((()())((((()(()())(())(()()(((())((()(((()()(((()()((((((())))())(()((((((()(()))()))()()((()((()))))()(()()(()((()()))))))(((((()(((((())()()()(())())))))))()))((()()(())))(())(()()()())))))(()((((())))))))()()(((()(()(()(()(()())()()()(((((((((()()())()(()))((()()()()()(((((((()())()((())()))((((((()(()(()(()())(((()(((((((()(((())(((((((((())(())())()))((()(()))(((()()())(())(()(()()(((()(())()))())))(())((((((())(()()())()()(((()(((())(()(((())(((((((()(((((((((()))(())(()(()(()))))((()))()(())())())((()(()((()()))((()()((()(())(())(()((())(((())(((()()()((((((()()(())((((())()))))(())((()(()((())))(((((()(()()())())((())())))((())((()((()()((((((())(((()()(()())())(()(()))(()(()))())())()(((((((()(((()(())()()((())((()(()()((()(()()(((((((((((())((())((((((())((()((((()(()((((()(((((((())()((()))))())()((()((((()(()(((()((()())))(())())(((()(((())((((((()(((((((((()()(())))(()(((((()((((()())))((()((()((()(()()(((())((((((((((((()(((())(()(((((()))(()()(()()()()()()((())(((((((())(((((())))))())()(()()(()(()(((()()(((((())(()((()((()(((()()((()((((())()))()((((())(())))()())(((())(())(()()((()(((()()((((((((((()()(()())())(((((((((())((((()))()()((((())(()((((()(((())())(((((((((((()((((())))(())(()(((()(((()((())(((((()((()()(()(()()((((((()((((()((()(()((()(()((((((()))))()()(((((()((()(()(())()))(())(((((((()((((()())(()((()((()(()))())))(())((()))))(((((((()()()())(()))(()()((()())()((()((()()()(()(()()))(()())(())(((((()(((((((((((()((()(((()(((((((()()((((((()(((((()(()((()(((((())((((((()))((((())((()()((())(((())()(((((()()(((((()((()(()(((((((()(((((()((()((()((())(())((())(()))()()))(()()(()(()()(((((((()(((()(((())()(((((()((((((()())((((())()((()((()(()()())(()))((((()()((((((()((()(()(()((((()((()((())((((((()(()(())((((((()((((((((((()((())()))()(()(()(((((()()()))((())))()(()((((((((((((((()(((()((((()((())((()((()(((()()(()(((()((())(()()())))()(()(()(((((()()(()(()((((()(((((())()(()(()))(((((()()(((()()(())((((((((((((((())((())(((((((((((())()()()(())()(()(()(((((((((())(((()))(()()())(()((((()(())(((((()())(())((((((((())()((((()((((((())(()((()(())(((()((((()))(((((((((()()))((((()(())()()()(())(()((())((()()))()(((())(((((())((((((()()))(((((((((()((((((())))(((((((()((()(()(())))())(()(()))()(((((()())(()))()(()(())(((()))))())()())))(((((()))())()((()(()))))((()()()((((((()))()()((((((((())((()(()(((()(()((())((()())(()((((())(()(((()()()(()(()()))())())((((((((((())())((()))()((())(())(())))())()(()()(())))())(()))(((()(()()(((()(((())))()(((()(())()((((((())()))()))()((((((()(()(((((()())))()))))())()()(((()(((((())((()()(()((()((()(()(()(())))(()()()()((()(())(((()((()))((((()))())(())))())(()))()()()())()))(((()()())()((())))(())(()()()()(()())((()(()()((((())))((()((()(())((()(()((())()(()()(((()())()()())((()))((())(((()()(())))()()))(((()((())()(((((()())(())((())()())())((((((()(()(((((()))(()("""
    print(instructions.count('(') - instructions.count(')'))

def DayOnePuzzleTwo():
    instructions = """()(((()))(()()()((((()(((())(()(()((((((()(()(((())))((()(((()))((())(()((()()()()(((())(((((((())))()()(()(()(())(((((()()()((())(((((()()))))()(())(((())(())((((((())())))(()())))()))))()())()())((()()((()()()()(()((((((((()()())((()()(((((()(((())((())(()))()((((()((((((((())()((()())(())((()))())((((()())(((((((((((()()(((((()(()))())(((()(()))())((()(()())())())(()(((())(())())()()(()(()((()))((()))))((((()(((()))))((((()(()(()())())()(((()((((())((((()(((()()(())()()()())((()((((((()((()()))()((()))()(()()((())))(((()(((()))((()((()(()))(((()()(()(()()()))))()()(((()(((())())))))((()(((())()(()(())((()())))((((())))(()(()(()())()((()())))(((()((()(())()()((()((())(()()((())(())()))()))((()(())()))())(((((((()(()()(()(())())))))))(()((((((())((((())((())())(()()))))()(())(()())()())((())(()))))(()))(()((()))()(()((((((()()()()((((((((()(()(())((()()(()()))(())()())()((())))()))()())(((()))(())()(())()))()((()((()(()()())(())()()()((())())))((()()(()()((()(())()()())(((()(()()))))(())))(()(()())()))()()))))))()))))((((((())))())))(()(())())(()())))))(()))()))))))()((()))))()))))(()(()((()())())(()()))))(((())()))())())())(((()(()()))(())()(())(())((((((()()))))((()(()))))))(()))())(((()()(()))()())()()()())))))))))))))(())(()))(()))((()(())(()())(())())(()())(())()()(()())))()()()))(())())()))())())(())((())))))))(())))(())))))()))))((())(()(((()))))(()))()((()(())))(()())(((((()))()())()()))))()))))()))())(()(()()()))()))))))((()))))))))))()((()))((()(())((())()()(()()))()(()))))()()(()))()))(((())))(())()((())(())(()())()())())))))))())))()((())))()))(()))()()))(((((((()))())(()()))(()()(()))()(()((()())()))))))(((()()()())))(())()))()())(()()))()()))))))))(())))()))()()))))))()))()())))()(())(())))))()(())()()(()()))))())((()))))()))))(()(((((()))))))))())))())()(())()()))))(())))())()()())()()())()(()))))()))()))))))))())))((()))()))()))())))()())()()())))())))(()((())()((()))())))))())()(())((())))))))))))())()())(())())())(()))(()))()))())(()(())())()())()()(()))))(()(())))))))(())))())(())))))))())()()(())())())))(())))))()))()(()())()(()))())())))))()()(()))()))))())))))))))()))))()))))))())()())()()))))()())))())))))))))))()()))))()()(((()))()()(())()))))((()))))(()))(())())))(())()))))))(()))()))))(())())))))()))(()())))))))))))))())))))))))()((()())(()())))))))((()))))(())(())))()(()())())))())())(()()()())))()))))))())))))())()()())))))))))))()()(()))))()())()))((()())(()))))()(()))))))))))()())())(((())(()))))())()))()))()))))))()))))))(()))))()))))()(())))(())))(()))())()()(()()))()))(()()))))))))()))(()))())(()()(()(()())()()))()))))))))(())))))((()()(()))())())))))()))())(()())()()))())))()(()()()()))((())())))())()(()()))()))))))))(()))(())))()))))(()(()())(()))))()())())()))()()))())))))))))))())()))))))()))))))))())))))()))))())(()())))(())()))())())))))()()(()()())(()())))()()))(((()))(()()()))))()))))()))))((())))()((((((()()))))))())))))))))))(((()))))))))))))(())())))))())(()))))))(()))((()))())))()(()((()))()))()))))))))))())()))()(()()))))())))())(())()(()))()))())(()))()))))(()()))()()(())))))()))(())(()(()()))(()()())))))(((()))))))()))))))))))))(())(()))))()())())()()((()()))())))))(()))))())))))))()()()))))))))())))()(((()()))(())))))(((())())))))((()))()(()))(()))))(()())))(()))())))))()))))(())(())))()((()))(())())))()()))()))))))))()))(()()()(()()()(()))())(())()())(((()))(())))))))))(((()())))()()))))))))()(())(()))()((((())(())(()())))()))(((())()()()))((()))(()))())())))())))(()))())()())())(()(())())()()()(())))())(())))(())))(())()))()))(()((()))))))))())(()))))))())(()()))()()))()(()(()())))()()(()((()((((((()))(())))()()()))())()))((()()(()))())((()(()(()))(()()))))()())))()))()())))))))()()((()())(())))()))(()))(())(()))())(()(())))()()))))))(((()(((()()))()(()(())())((()()))()))()))()))()(()()()(()))((()())()(())))()()))(((())()()())(())()((()()()()(()(())(()()))()(((((()())))((())))))(()()()))))(((()(())))()))((()((()(())()(()((())))((()())()(()))(((()())()()(()))(())(((()((()())()((())()())(((()()))((()((())(()))(()())(()()()))((()))(())(()((()()())((()))(())))(())(())(())))(()())))(((((()(()(((((()())((((()(()())(())(()()(((())((()(((()()(((()()((((((())))())(()((((((()(()))()))()()((()((()))))()(()()(()((()()))))))(((((()(((((())()()()(())())))))))()))((()()(())))(())(()()()())))))(()((((())))))))()()(((()(()(()(()(()())()()()(((((((((()()())()(()))((()()()()()(((((((()())()((())()))((((((()(()(()(()())(((()(((((((()(((())(((((((((())(())())()))((()(()))(((()()())(())(()(()()(((()(())()))())))(())((((((())(()()())()()(((()(((())(()(((())(((((((()(((((((((()))(())(()(()(()))))((()))()(())())())((()(()((()()))((()()((()(())(())(()((())(((())(((()()()((((((()()(())((((())()))))(())((()(()((())))(((((()(()()())())((())())))((())((()((()()((((((())(((()()(()())())(()(()))(()(()))())())()(((((((()(((()(())()()((())((()(()()((()(()()(((((((((((())((())((((((())((()((((()(()((((()(((((((())()((()))))())()((()((((()(()(((()((()())))(())())(((()(((())((((((()(((((((((()()(())))(()(((((()((((()())))((()((()((()(()()(((())((((((((((((()(((())(()(((((()))(()()(()()()()()()((())(((((((())(((((())))))())()(()()(()(()(((()()(((((())(()((()((()(((()()((()((((())()))()((((())(())))()())(((())(())(()()((()(((()()((((((((((()()(()())())(((((((((())((((()))()()((((())(()((((()(((())())(((((((((((()((((())))(())(()(((()(((()((())(((((()((()()(()(()()((((((()((((()((()(()((()(()((((((()))))()()(((((()((()(()(())()))(())(((((((()((((()())(()((()((()(()))())))(())((()))))(((((((()()()())(()))(()()((()())()((()((()()()(()(()()))(()())(())(((((()(((((((((((()((()(((()(((((((()()((((((()(((((()(()((()(((((())((((((()))((((())((()()((())(((())()(((((()()(((((()((()(()(((((((()(((((()((()((()((())(())((())(()))()()))(()()(()(()()(((((((()(((()(((())()(((((()((((((()())((((())()((()((()(()()())(()))((((()()((((((()((()(()(()((((()((()((())((((((()(()(())((((((()((((((((((()((())()))()(()(()(((((()()()))((())))()(()((((((((((((((()(((()((((()((())((()((()(((()()(()(((()((())(()()())))()(()(()(((((()()(()(()((((()(((((())()(()(()))(((((()()(((()()(())((((((((((((((())((())(((((((((((())()()()(())()(()(()(((((((((())(((()))(()()())(()((((()(())(((((()())(())((((((((())()((((()((((((())(()((()(())(((()((((()))(((((((((()()))((((()(())()()()(())(()((())((()()))()(((())(((((())((((((()()))(((((((((()((((((())))(((((((()((()(()(())))())(()(()))()(((((()())(()))()(()(())(((()))))())()())))(((((()))())()((()(()))))((()()()((((((()))()()((((((((())((()(()(((()(()((())((()())(()((((())(()(((()()()(()(()()))())())((((((((((())())((()))()((())(())(())))())()(()()(())))())(()))(((()(()()(((()(((())))()(((()(())()((((((())()))()))()((((((()(()(((((()())))()))))())()()(((()(((((())((()()(()((()((()(()(()(())))(()()()()((()(())(((()((()))((((()))())(())))())(()))()()()())()))(((()()())()((())))(())(()()()()(()())((()(()()((((())))((()((()(())((()(()((())()(()()(((()())()()())((()))((())(((()()(())))()()))(((()((())()(((((()())(())((())()())())((((((()(()(((((()))(()("""
    floor = 0
    count = 0
    for i in instructions:
        if i == '(':
            floor += 1
        elif i == ')':
            floor -= 1 
        count += 1
        if floor == -1:
            print(count)  

def DayTwoPuzzleOne():

    def calculateArea(line):
        lengths = line.split('x')
        for i in range(len(lengths)):
            lengths[i] = int(lengths[i])
        end = lengths[0]*lengths[1]
        top = lengths[0]*lengths[2]
        side = lengths[1]*lengths[2]
        slack = min(end, top, side)
        return 2*sum([end, top, side]) + slack
    
    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 2 Puzzle 1 input.txt', 'r') as f:
        total = 0
        for line in f.readlines():
            total += calculateArea(line)
        print(total)

def DayTwoPuzzleTwo():

    def getRibbonLength(line):
        lengths = line.split('x')
        for i in range(len(lengths)):
            lengths[i] = int(lengths[i])
        
        lengths = sorted(lengths)
        return (2*lengths[0] + 2*lengths[1]) + (lengths[0]*lengths[1]*lengths[2])

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 2 Puzzle 1 input.txt', 'r') as f:
        total = 0
        for line in f.readlines():
            total += getRibbonLength(line)
        print(total)

def DayThree1():

    def maxDisplacement(instructions, direction, opposite):
        displacement, maxDirection, maxOpposite = 0, 0, 0
        for i in instructions:
            if i == direction:
                displacement += 1
            elif i == opposite:
                displacement -= 1
            if displacement > maxDirection:
                maxDirection = displacement
            if displacement < maxOpposite:
                maxOpposite = displacement
        return maxDirection, abs(maxOpposite)        

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 3 Puzzle 1 input.txt', 'r') as f:
        instructions = []
        for line in f.readlines():
            for i in line:
                if i in '^<>v':
                    instructions.append(i)

    maxNorth, maxSouth = maxDisplacement(instructions, '^', 'v')
    maxWest, maxEast = maxDisplacement(instructions, '<', '>')
    print((maxNorth, maxEast, maxSouth, maxWest))

    grid = list([0 for house in range(maxWest + maxEast + 1)] for row in range((maxNorth + maxSouth + 1)))
    print(len(grid))
    print(len(grid[0]))

    x = maxWest - 1
    y = maxNorth - 1

    go = {'x':{'>':1, '<':-1}, 'y':{'^':1, 'v':-1}}

    for item in instructions:
        grid[y][x] += 1
        if item in '<>':
            x += go['x'][item]
        else:
            y += go['y'][item]
    grid[y][x] += 1

    housesHit = 0

    for row in grid:
        for house in row:
            if house != 0:
                housesHit += 1

    print(housesHit)
        

def DayThree2():

    def maxDisplacement(instructions, direction, opposite):
        displacement, maxDirection, maxOpposite = 0, 0, 0
        for i in instructions:
            if i == direction:
                displacement += 1
            elif i == opposite:
                displacement -= 1
            if displacement > maxDirection:
                maxDirection = displacement
            if displacement < maxOpposite:
                maxOpposite = displacement
        return maxDirection, abs(maxOpposite)

    def santaJourney(instructions, grid):
        x = maxWest - 1
        y = maxNorth - 1

        go = {'x':{'>':1, '<':-1}, 'y':{'^':1, 'v':-1}}

        for item in instructions:
            grid[y][x] += 1
            if item in '<>':
                x += go['x'][item]
            else:
                y += go['y'][item]
        grid[y][x] += 1

        return grid
        

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 3 Puzzle 1 input.txt', 'r') as f:
        instructions = []
        roboInstructions = []
        count = 0
        for line in f.readlines():
            for i in line:
                count += 1
                if i in '^<>v':
                    if count % 2 == 1:
                        instructions.append(i)
                    else:
                        roboInstructions.append(i)

    n1, s1 = maxDisplacement(instructions, '^', 'v')
    w1, e1 = maxDisplacement(instructions, '<', '>')
    n2, s2 = maxDisplacement(roboInstructions, '^', 'v')
    w2, e2 = maxDisplacement(roboInstructions, '<', '>')

    maxNorth, maxEast, maxSouth, maxWest = max(n1,n2), max(e1,e2), max(s1,s2), max(w1,w2)

    grid = list([0 for house in range(maxWest + maxEast + 1)] for row in range((maxNorth + maxSouth + 1)))
                        
    grid = santaJourney(instructions, grid)
    grid = santaJourney(roboInstructions, grid)

    housesHit = 0

    for row in grid:
        for house in row:
            if house != 0:
                housesHit += 1

    print(housesHit)
    

def DayFour():

    from hashlib import md5

    key = b'bgvyzdsv'
    digits = 0

    while True:
        digits += 1
        if md5(b'%s%s' % (key, bytes(str(digits), 'utf-8'))).hexdigest()[:6] == '000000': # remove one zero in this string and change index to [:5] for puzzle one
            print(digits)
            break
        
def DayFive1():

    nice = 0

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 5 Input.txt', 'r') as f:
        for line in f.readlines():
            if len([x for x in line if x in 'aeiou']) > 2 and len([line[x-1:x+1] for x in range(1, len(line)) if line[x] == line[x-1]]) > 0 and len([line[x-1:x+1] for x in range(1, len(line)) if line[x-1:x+1] in ['ab', 'cd', 'pq', 'xy']]) == 0:
                nice += 1
                
        print(nice)

def DayFive2():

    nice = 0

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 5 Input.txt', 'r') as f:
        for line in f.readlines():
            if len([line[x-2:x] for x in range(2, len(line)) if line[x-2:x] in line[x:]]) > 0 and len([line[x:x+3] for x in range(len(line) - 2) if line[x] == line[x+2]]) > 0:
                nice += 1
                
        print(nice)
        
def DaySix1():

    def lights(grid, instruction, l, r, u, d):
        for y in range(u, d + 1):
            for x in range(l, r + 1):
                if instruction == 'on':
                    grid[y][x] = 'X'
                elif instruction == 'off':
                    grid[y][x] = ' '
                elif instruction == 'oggle':
                    if grid[y][x] == 'X':
                        grid[y][x] = ' '
                    elif grid[y][x] == ' ':
                        grid[y][x] = 'X'

    grid = [[' ' for x in range(1000)] for y in range(1000)]
    total = 0

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 6 Input.txt'
    with open(file, 'r') as f:
        for line in f.readlines():
            line = line.strip('turn \n').split()

            topLeft, bottomRight = line[1].split(','), line[3].split(',')

            l, r, u, d = int(topLeft[0]), int(bottomRight[0]), int(topLeft[1]), int(bottomRight[1])

            lights(grid, line[0], l, r, u, d)

        for row in grid:
            total += row.count('X')

        print(total)

def DaySix2():

    def lights(grid, instruction, l, r, u, d):
        for y in range(u, d + 1):
            for x in range(l, r + 1):
                if instruction == 'on':
                    grid[y][x] += 1
                elif instruction == 'off' and grid[y][x] != 0:
                    grid[y][x] -= 1
                elif instruction == 'oggle':
                    grid[y][x] += 2

    grid = [[0 for x in range(1000)] for y in range(1000)]
    total = 0

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 6 Input.txt'
    with open(file, 'r') as f:
        for line in f.readlines():
            line = line.strip('turn \n').split()

            topLeft, bottomRight = line[1].split(','), line[3].split(',')

            l, r, u, d = int(topLeft[0]), int(bottomRight[0]), int(topLeft[1]), int(bottomRight[1])

            lights(grid, line[0], l, r, u, d)

        for row in grid:
            total += sum(row)

        print(total) 

                

def DaySeven1():

    def evalWire(wire, depth):
        print(wire)
        print(depth)
        '''
        operation = wires[wire]
        print(operation)'''
        try:
            int(wire)
##            print('evaluated %s' % int(wire))
            depth -= 1
            return int(wire)
            '''
#            print('evaluated %s' % wire)
            if len(operation) == 1:
                return int(operation[0]) # once it gets back to a number, return that as an int
            else:
                raise ValueError'''
        
        except ValueError:
            operation = wires[wire]
##            print('%s %s' % (operation, wire))
            if len(operation) == 1:
                return evalWire(operation[0], depth + 1) # if it's a wire name only (no operation) or a number, evaluate the input and return it
            elif len(operation) == 2:
                '''if len(bin(evalWire(operation[1]))) < 18:
                    string = bin(evalWire(operation[1]))
                    print(string)
                    string = string[2:].zfill(16)
                    print(string)
                    thing = ''.join([['1','0'][int(x)] for x in string])
                    print(thing)'''
#                print(bin(evalWire(operation[1])))
#                print(bin(65535 - evalWire(operation[1])))
                return 65535 - evalWire(operation[1], depth+1) # if it's a NOT gate, evaluate the input and return the NOT of it NEED THIS TO BE 16BIT
            else:
                if 'AND' in operation:
                    return evalWire(operation[0], depth+1) & evalWire(operation[2], depth+1) # if it's an AND gate, evaluate the inputs and return their AND
                elif 'OR' in operation:
                    return evalWire(operation[0], depth+1) | evalWire(operation[2], depth+1) # if it's an OR gate, evaluate the inputs and return their OR
                elif 'LSHIFT' in operation:
                    return evalWire(operation[0], depth+1) << int(operation[2]) # if it's an LSHIFT, evaluate the input and shift it the appropriate number left
                elif 'RSHIFT' in operation:
                    return evalWire(operation[0], depth+1) >> int(operation[2]) # if it's an RSHIFT, evaluate the input and shift it the appropriate number right

    def evalWire(wire, depth):

        depth += 1

        print(depth)

        if type(wires[wire]) == int:
            return wires[wire]

        try:
            print(int(wire))
            depth -= 1
            return int(wire)
        
        except ValueError:
            operation = wires[wire]
            if len(operation) == 1: # number or single wire case
                wires[wire] = evalWire(operation[0], depth)
                return evalWire(operation[0], depth)
            elif len(operation) == 2: # NOT case
                return 65535 - evalWire(operation[1], depth)
            else:
                if 'AND' in operation: # AND case
                    return evalWire(operation[0], depth) & evalWire(operation[2], depth)
                elif 'OR' in operation: # OR case
                    return evalWire(operation[0], depth) | evalWire(operation[2], depth)
                elif 'LSHIFT' in operation: # LSHIFT case
                    return evalWire(operation[0], depth) << int(operation[2])
                elif 'RSHIFT' in operation: # RSHIFT case
                    return evalWire(operation[0], depth) >> int(operation[2])
            

    wires = {}
    

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 7 Input.txt'
    with open(file, 'r') as f:
        for line in f.readlines():
            wires[line.split()[-1]] = line.split()[:-2]

#    for i in wires:
#        print(wires[i])
    
    print(evalWire('a', 0))
'''
    wires = {'x':['123'], 'y': ['456'], 'd': ['x', 'AND', 'y'], 'e': ['x', 'OR', 'y'], 'f':['x', 'LSHIFT', '2'], 'g':['y', 'RSHIFT', '2'], 'h': ['NOT', 'x'], 'i': ['NOT', 'y']}
        
    for i in list('xydefghi'):
        print('%s equals %s' % (i, evalWire(i)))
'''
            
            
def DaySeven1():

    def evalWire(operation):
        
        try:
            if len(operation) == 1:
                return wires[operation[0]]
            elif len(operation) == 2:
                return 65535 - wires[operation[1]]
            else:
                if 'AND' in operation:
                    return wires[operation[0]] & wires[operation[2]]
                elif 'OR' in operation:
                    return wires[operation[0]] | wires[operation[2]]
                elif 'RSHIFT' in operation:
                    return wires[operation[0]] >> int(operation[2])
                elif 'LSHIFT' in operation:
                    return wires[operation[0]] << int(operation[2])
            
        except TypeError:
            return None

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 7 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()

    wires = {line.split()[-1]:None for line in lines}
    for line in lines:
        for thing in line.split():
            if thing not in ['AND','OR','NOT','LSHIFT','RSHIFT', '->'] and thing not in wires.keys():
                wires[thing] = int(thing)
    while None in wires.values():
        for line in lines:
            operation = line.split()[:-2]
            wires[line.split()[-1]] = evalWire(operation)

    print(wires['a'])


def DaySeven2():

    def evalWire(operation):
        
        try:
            if len(operation) == 1:
                return wires[operation[0]]
            elif len(operation) == 2:
                return 65535 - wires[operation[1]]
            else:
                if 'AND' in operation:
                    return wires[operation[0]] & wires[operation[2]]
                elif 'OR' in operation:
                    return wires[operation[0]] | wires[operation[2]]
                elif 'RSHIFT' in operation:
                    return wires[operation[0]] >> int(operation[2])
                elif 'LSHIFT' in operation:
                    return wires[operation[0]] << int(operation[2])
            
        except TypeError:
            return None

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 7 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()

    wires = {line.split()[-1]:None for line in lines}

    for i in range(len(lines)):
        if lines[i].split()[-1] == 'b':
            lines[i] = '46065 -> b\n'
            
    for line in lines:
        for thing in line.split():
            if thing not in ['AND','OR','NOT','LSHIFT','RSHIFT', '->'] and thing not in wires.keys():
                wires[thing] = int(thing)
    while None in wires.values():
        for line in lines:
            operation = line.split()[:-2]
            wires[line.split()[-1]] = evalWire(operation)

    print(wires['a'])




def DayEight1():

    import re

    an = re.compile('\w')
    dq = re.compile(r'\\\"')
    bs = re.compile(r'\\\\')
    uc = re.compile(r'\\x[0123456789abcdef]{2,2}')

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 8 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()
#        lines = [f.readline() for i in range(20)]

    codeTotal = 0
    memTotal = 0

    for line in lines:
        '''
        print('line:')
        print(line)
        print(len(line))

        print('alphanumeric:')
        print(an.findall(line))
        print(len(an.findall(line)))

        print('double quotes:')
        print(dq.findall(line))
        print(len(dq.findall(line)))

        print('backslashes:')
        print(bs.findall(line))
        print(len(bs.findall(line)))
        

        if len(line) - 1 != len(an.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line)) + len(uc.findall(line)) + 2:
            print(line)
            print(len(an.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line)) + len(uc.findall(line)) + 2)
            print(bs.findall(line))
            print(dq.findall(line))
        '''
        codeTotal += len(line) - 1
        # the codeTotal below is getting the wrong answer for lines that end in \\, because it counts as
        # both a backslash and an escaped quote. stripping the line first should help.
#        codeTotal += len(an.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line)) + len(uc.findall(line)) + 2

#        print('code total:')
#        print(len(an.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line)) + len(uc.findall(line)) + 2)
        # not sure if this strip should cause issues with lines ending \"" but it seems to work...
        line = line.strip('\n"')
        '''
        print('unicode:')
        print(uc.findall(line))
        print(len(uc.findall(line)))

        print('len(line) after strip:')
        print(len(line))
        '''
        memTotal += len(line) - 3*len(uc.findall(line)) - len(dq.findall(line)) - len(bs.findall(line))
#        print('mem total:')
#        print(len(line) - 3*len(uc.findall(line)) - len(dq.findall(line)) - len(bs.findall(line)))
        
#        print('-'*20)

    print(codeTotal - memTotal)

def DayEight2():

    import re

    an = re.compile('\w')
    dq = re.compile(r'\\\"')
    bs = re.compile(r'\\\\')
    uc = re.compile(r'\\x[0123456789abcdef]{2,2}')

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 8 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()
#        lines = [f.readline() for i in range(20)]

    originalCodeTotal = 0
    encodedTotal = 0

    for line in lines:

        line = line[1:-2]

        originalCodeTotal += len(line) - 1

        encodedTotal += len(line) + 3 + len(uc.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line))
        #                   outer quotes    \ for unicode       \\ for quotes               \\ for backslash

    print(encodedTotal - originalCodeTotal)

        
        


def DayNine1():

    def trimRoutes(routes, visited):
        new = []
        for route in routes:
            if route[1] in visited or route[2] in visited:
                continue
            else:
                new.append(route)               
        return new
    
    def listForEachPlace(place):
        thisPlace = []
        for route in routes:
            if place in route:
                thisPlace.append([x for x in route if x != place])
        return thisPlace

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 9 Input.txt'

    with open(file, 'r') as f:
        routes = [sorted([line.split()[-1], line.split()[0], line.split()[2]]) for line in f.readlines()]

    print(routes)
    
    Faerun = listForEachPlace('Faerun')
    Tristram = listForEachPlace('Tristram')
    Tambi = listForEachPlace('Tambi')
    Norrath = listForEachPlace('Norrath')
    Snowdin = listForEachPlace('Snowdin')
    Straylight = listForEachPlace('Straylight')
    AlphaCentauri = listForEachPlace('AlphaCentauri')
    Arbre = listForEachPlace('Arbre')

    destinations = [Faerun, Tristram, Tambi, Norrath, Snowdin, Straylight, AlphaCentauri, Arbre]
    places = ['Faerun', 'Tristram', 'Tambi', 'Norrath', 'Snowdin', 'Straylight', 'AlphaCentauri', 'Arbre']

    mapping = {x:places[x] for x in range(len(places))}

    journeys = [
        []
        ]
    
    print('%s\n'*8 % (Faerun, Tristram, Tambi, Norrath, Snowdin, Straylight, AlphaCentauri, Arbre))

    shortest = 0
    
    for place in destinations:
        visited = []
        start = place
        for place in places:
            if place == start:
                continue
            
        
        

def dayNine1():

    import itertools

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 9 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()

    routes = [(line.split()[0], line.split()[2], line.split()[4]) for line in lines]

    places = set([line.split()[0] for line in lines] + ['Arbre'])

    poss = {}
    
    for x in itertools.combinations(routes, 7):
        check = {m:0 for m in places}
        for p in places:
            for r in x:
                if p in r:
                    check[p] += 1
        s = ' '.join([str(n) for n in check.values()])
        if s.count('2') == 6 and s.count('1') == 2:
            poss[sum([int(y[2]) for y in x])] = x
            # poss.append(sum([int(y[2]) for y in x]))
    
    print('Part 1: {}'.format(min(poss)))
    print('Route: {}'.format(poss[min(poss.keys())]))
    print()
    print('Part 2: {}'.format(max(poss)))
    print('Route: {}'.format(poss[max(poss.keys())]))

        
   
    



    

    

def DayTen1():

    n = [1,1,1,3,1,2,2,1,1,3]

    def cycle(n):

        new = []

        for i in n:
            try:
                if i == new[-1]:
                    new[-2] += 1
                else:
                    raise IndexError           
            except IndexError:
                new.extend([1, i])

        return new

    for x in range(50):
#        print('%s: %s' % (x, n))
        n = cycle(n)

    print(len(n))



def DayEleven1():

    def rule1(passnum):
        for i in range(2, len(passnum)):
            try:
                if passnum[i] == passnum[i-1] + 1 == passnum[i-2] + 2:
                    return True
            except IndexError:
                print('i = {}, passnum = {}'.format(i, passnum))
        return False

    def rule2(passnum):
        for letter in [8, 11, 14]:
            if letter in passnum:
                for i in range(passnum.index(letter) + 1, len(passnum)):
                    passnum[i] = 0
                passnum[passnum.index(letter)] += 1
                return False
        return True

    def rule3(passnum):
        pairs = []
        for i in range(len(passnum) - 1):
            if passnum[i] == passnum[i+1] and passnum[i] not in pairs:
                pairs.append(passnum[i])
        return len(pairs) >= 2        

    def increment(passnum):
        passnum[-1] += 1
        for i in range(len(passnum)):
            if passnum[len(passnum) - (i+1)] == 26:
                passnum[len(passnum) - (i+1)] = 0
                passnum[len(passnum) - (i+2)] += 1
                

    password = 'cqjxxyzz'
    alph = 'abcdefghijklmnopqrstuvwxyz'

    passnum = []
    for i in password:
        passnum.append(alph.find(i))

    count = 0
    while not (rule1(passnum) and rule2(passnum) and rule3(passnum)) or count == 0:
        increment(passnum)
        count += 1

    print(''.join([alph[x] for x in passnum]))

        

def dayTwelve1():

    import re

    n = re.compile('-?\d+')

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 12 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()

    nums = []
    for line in lines:
        nums.extend(n.findall(line))

    print('\n'.join(nums))

    for i in range(len(nums)):
        nums[i] = int(nums[i])

    print(sum(nums))

'''        
def dayTwelve2(): # red currently doesn't work as it will stop at "{"red"{{}" rather than "{"red"{{}}}"

    import re

    n = re.compile('-?\d+')
    red = re.compile('\{[^}[]*\"red\"[^}]*\}')

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 12 Input.txt'

    with open(file, 'r') as f:
        lines = f.readline()

    nums = n.findall(lines)

    redobjects = red.findall(lines)

    rednums = []
    for d in redobjects:
        rednums.extend(n.findall(d))

    for d in redobjects:
        print(d)
        print(n.findall(d))
    
    for i in range(len(nums)):
        nums[i] = int(nums[i])
    for i in range(len(rednums)):
        rednums[i] = int(rednums[i])

    print(sum(nums) - sum(rednums))
'''

def dayTwelve2():

    import re

    openBrace = re.compile('\{')
    closeBrace = re.compile('\}')
    red = re.compile('\{[^}[]*\"red\"[^}]*\}')

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 12 Input.txt'

    with open(file, 'r') as f:
        stuff = f.readline()

        
    '''
    # find { character
    # from that index, look for { or }
    # if { go back to start
    # if } separate out (maybe check for "red" here)

    # could try counting open braces and close braces
    # if "red" is found, ignore until count drops below the level at which it was found'''

    # make a list of all indices at which "red" occurs

    count = 0

    reds = []
    start = 0
    count = 0
    while True:
        count += 1
        r = start + stuff[start:].find('\"red\"')
        if r == start-1:
            break
        reds.append(r)
        start += stuff[start:].find('\"red\"') + 5

    print(len(reds))

# find the { before that, and find when that object ends
# CURRENTLY NOT IGNORING "red" IN LISTS. UGH. Add a continue if [ found before {.

    def findObjectEnd(index, d, char, oppchar):
        count = 1
        dist = 0
        for l in stuff[index::d]:
            dist += 1
            if l == char:
                count += 1
            elif l == oppchar:
                count -= 1
            if count == 0:
                return index + d*dist
                

    redObjects = []

    debuglength = 5

    reds = [reds[x] for x in range(debuglength)]
    #print(reds)
    for index in reds:
        listStart = findObjectEnd(index, -1, '[', ']')
        listEnd = findObjectEnd(index, 1, ']', '[')
        dictStart = findObjectEnd(index, -1, '{', '}')
        dictEnd = findObjectEnd(index, 1, '}', '{')
        print('Enclosing list:\n{}'.format(stuff[listStart:listEnd + 1]))
        print('Enclosing dict:\n{}'.format(stuff[dictStart:dictEnd + 1]))
        if stuff[index::-1].find('[') < stuff[index::-1].find('{'): # need to do a count for this too. Make a function.
            continue
        #objectStart = index - stuff[index::-1].find('{') # need to do the count below for this too
        #print(stuff[objectStart:index + 5])
        
        count = 1
        dist = 0
        for l in stuff[index::-1]:
            dist += 1
            if l == '{':
                count += 1
                #print('Count increased to {} at distance {}'.format(count, dist))
            elif l == '}':
                count -= 1
                #print('Count decreased to {} at distance {}'.format(count, dist))
            if count == 0:
                objectStart = index - dist
                break
        count = 1
        dist = 0
        for l in stuff[index:]:
            dist += 1
            if l == '{':
                count += 1
                #print('Count increased to {} at distance {}'.format(count, dist))
            elif l == '}':
                count -= 1
                #print('Count decreased to {} at distance {}'.format(count, dist))
            if count == 0:
                objectEnd = index + dist
                break
        redObjects.append((objectStart, objectEnd))

    print(len(redObjects))

    moot = []

    for inset in redObjects:
        for obj in redObjects:
            if inset[0] > obj[0] and inset[1] < obj[1]:
                moot.append(inset)

    print(len(set(moot)))

    for i in range(1, len(redObjects)):
        if redObjects[i] == redObjects[i - 1]:
            print('{}: {}'.format(i, redObjects[i]))

    exclude = [obj for obj in redObjects if obj not in moot]
    print(len(exclude))

    print(stuff[1597:1938] + '\n' + stuff[1870:3855])

        

    
        
# run dayTwelve1() on the remaining input


def dayTwelve2():

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 12 Input.txt'

    with open(file, 'r') as f:
        stuff = f.readline()

    # creates a list with the start index of all occurences of "red"
    reds = []
    start = 0
    count = 0
    while True:
        count += 1
        r = start + stuff[start:].find('\"red\"')
        if r == start-1:
            break
        reds.append(r)
        start += stuff[start:].find('\"red\"') + 5

    print(len(reds))

    def findLimit(index, d, char, oppchar):
        count = 1
        dist = 0
        for l in stuff[index + d::d]:
            dist += 1
            if l == char:
                count -= 1
            elif l == oppchar:
                count += 1
            if count == 0:
                return index + d*dist

    objs = []
    start = 0
    count = 0
    while True:
        o = start + stuff[start:].find('{')
        if o == start - 1:
            break
        objs.append((o, findLimit(o, 1, '}', '{') + 1))
        start = o + 1
    for n in range(10):
        print(objs[n])
        print(stuff[objs[n][0]:objs[n][1]])

    highestObjs = []
    for x in objs:
        for y in objs:
            if x[0] > y[0] and x[1] > y[1]:
                continue
        highestObjs.append(x)

    print(len(objs))
    print(len(highestObjs))
                


    
    


        

#dayTwelve2()



def dayThirteen1():

    from itertools import permutations, combinations

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 13 Input.txt'
    with open(file, 'r') as f:
        lines = f.readlines()

    d = {'gain':1, 'lose':-1}

    rules = {line.split()[0] + line.split()[-1][:-1]:d[line.split()[2]]*int(line.split()[3]) for line in lines}

    guests = sorted(set([line.split()[0] for line in lines]))

    optimum = 0
    count = 0
    for perm in permutations(guests):
        count += 1
        #print(perm)
        happiness = 0
        for i in range(-1, len(perm)-1):
            ref = perm[i] + perm[i+1]
            happiness += rules[ref]
            ref = perm[i+1] + perm[i]
            happiness += rules[ref]
            #print('Happiness = {}'.format(happiness))
            #print('pair: {}, change: {}'.format(ref, rules[ref]))
        optimum = max(optimum, happiness)
        #if count == 10: break       

    print('Part 1: {}'.format(optimum))

    guests.append('You')

    optimum = 0
    for perm in permutations(guests):
        happiness = 0
        for i in range(-1, len(perm) - 1):
            ref = perm[i] + perm[i+1]
            if "You" in ref:
                continue
            happiness += rules[ref]
            ref = perm[i+1] + perm[i]
            happiness += rules[ref]
        optimum = max(optimum, happiness)

    print('Part 2: {}'.format(optimum))


             


def dayFourteen1():

    def reindeer(v, t, rest, total):

        elapsed = 0
        dist = 0

        while elapsed + rest + t <= total:
            dist += v*t
            elapsed += t + rest

        if t <= total - elapsed:
            dist += v*t
        else:
            dist += v*(total - elapsed)

        return dist

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 14 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()

    deer = [[line.split()[0], int(line.split()[3]), int(line.split()[6]), int(line.split()[-2])] for line in lines]

    furthest = 0

    for d in deer:
        print('{name} travelled {dist}km'.format(name = d[0], dist = reindeer(d[1], d[2], d[3], 2503)))
        if reindeer(d[1], d[2], d[3], 2503) > furthest:            
            furthest = reindeer(d[1], d[2], d[3], 2503)

    print(furthest)
        
        
            
def dayFourteen2():

    def reindeer(v, t, rest, total):

        elapsed = 0
        dist = 0

        while elapsed + rest + t <= total:
            dist += v*t
            elapsed += t + rest

        if t <= total - elapsed:
            dist += v*t
        else:
            dist += v*(total - elapsed)

        return dist

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 14 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()

    deer = [[line.split()[0], int(line.split()[3]), int(line.split()[6]), int(line.split()[-2])] for line in lines]
    scores = {d[0]:0 for d in deer}

    second = 0
    total = 2503
    furthest = 0
    
    while second <= total:
        second += 1
        for d in deer:
            if reindeer(d[1], d[2], d[3], second) > furthest:            
                furthest = reindeer(d[1], d[2], d[3], second)
                lead = d[0]
        scores[lead] += 1

    print(scores)  
        
    

def dayFifteen1():

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 15 Input.txt'
    with open(file, 'r') as f:
        ings = {}
        for line in f.readlines():
            l = line.split()
            ings[l[0][:-1]] = [int(l[2][:-1]), int(l[4][:-1]), int(l[6][:-1]), int(l[8][:-1]), int(l[10])]

    '''
    ings = {'Butterscotch': [-1, -2, 6, 3, 8],
        'Cinammon': [2, 3, -2, -1, 3]}

    optimum = 0
    for but in range(101):
                cin = 100 - but
                print('cinammon: {}, buttercotch: {}'.format(cin, but))
                scores = [(cin*ings['Cinammon'][a] + but*ings['Butterscotch'][a]) for a in range(4)]
                print(scores)
                total = 1
                for s in range(len(scores)):
                    if scores[s] < 0:
                        break                   
                    print('{} x {} = {}'.format(total, scores[s], total*scores[s]))
                    total *= scores[s]
                optimum = max(total, optimum)
                print('max = {}'.format(optimum))
                print()
    '''
    
    optimum = 0
    for spr in range(101):
        for butt in range(101 - spr):
            for choc in range(101 - (spr+butt)):
                cand = 100 - (spr+butt+choc)
                scores = [(spr*ings['Sprinkles'][a] + butt*ings['Butterscotch'][a] + choc*ings['Chocolate'][a] + cand*ings['Candy'][a]) for a in range(4)]
                total = 1
                for s in range(len(scores)):
                    if scores[s] < 0:
                        break
                    total *= scores[s]
                optimum = max(total, optimum)

    print(optimum)
    print('{} combinations were tried.'.format(tried))


def fifteen1speed(n): # n = number of trials of each. Takes approx 11*n seconds (on laptop)

    def dayFifteen1Slow():

        start = time.time()

        optimum = 0
        for spr in range(101):
            for butt in range(101):
                for choc in range(101):
                    cand = 100 - (spr+butt+choc)
                    scores = [(spr*ings['Sprinkles'][a] + butt*ings['Butterscotch'][a] + choc*ings['Chocolate'][a] + cand*ings['Candy'][a]) for a in range(4)]
                    total = 1
                    for s in range(len(scores)):
                        if scores[s] < 0:
                            scores[s] = 0
                        total *= scores[s]
                    optimum = max(total, optimum)

        return time.time() - start

    def dayFifteen1Fast():

        start = time.time()

        optimum = 0
        for spr in range(101):
            for butt in range(101 - spr):
                for choc in range(101 - (spr+butt)):
                    cand = 100 - (spr+butt+choc)
                    scores = [(spr*ings['Sprinkles'][a] + butt*ings['Butterscotch'][a] + choc*ings['Chocolate'][a] + cand*ings['Candy'][a]) for a in range(4)]
                    total = 1
                    for s in range(len(scores)):
                        if scores[s] < 0:
                            break
                        total *= scores[s]
                    optimum = max(total, optimum)

        return time.time() - start
    
    import time
    
    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 15 Input.txt'
    with open(file, 'r') as f:
        ings = {}
        for line in f.readlines():
            l = line.split()
            ings[l[0][:-1]] = [int(l[2][:-1]), int(l[4][:-1]), int(l[6][:-1]), int(l[8][:-1]), int(l[10])]

    fast = []
    slow = []
    
    for i in range(n):
        fast.append(dayFifteen1Fast())
        slow.append(dayFifteen1Slow())

    def avg(j):
        return sum(j)/len(j)

    print('Fast = {}\nSlow = {}\nPercentage = {}%'.format(avg(fast), avg(slow), (avg(fast)/avg(slow))*100))
        
    


def dayFifteen2():
    
    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 15 Input.txt'
    with open(file, 'r') as f:
        ings = {}
        for line in f.readlines():
            l = line.split()
            ings[l[0][:-1]] = [int(l[2][:-1]), int(l[4][:-1]), int(l[6][:-1]), int(l[8][:-1]), int(l[10])]

    optimum = 0
    for spr in range(101):
        for butt in range(101 - spr):
            for choc in range(101 - (spr+butt)):
                cand = 100 - (spr+butt+choc)
                if spr*ings['Sprinkles'][4] + butt*ings['Butterscotch'][4] + choc*ings['Chocolate'][4] + cand*ings['Candy'][4] != 500:
                    continue
                scores = [(spr*ings['Sprinkles'][a] + butt*ings['Butterscotch'][a] + choc*ings['Chocolate'][a] + cand*ings['Candy'][a]) for a in range(4)]
                total = 1
                for s in range(len(scores)):
                    if scores[s] < 0:
                        break
                    total *= scores[s]
                optimum = max(total, optimum)

    print(optimum)                   
                    


def DaySixteen1():

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 16 Input.txt'
    with open(file, 'r') as f:
        lines = f.readlines()

    sues = {}
    for line in lines:
        l = line.split()
        sues[int(l[1][:-1])] = {
            l[2][:-1]:int(l[3][:-1]),
            l[4][:-1]:int(l[5][:-1]),
            l[6][:-1]:int(l[7])
            }

    auntSue = {x.split()[0][:-1]:int(x.split()[1]) for x in '''children: 3
    cats: 7
    samoyeds: 2
    pomeranians: 3
    akitas: 0
    vizslas: 0
    goldfish: 5
    trees: 3
    cars: 2
    perfumes: 1'''.split('\n')}

    
    for n in range(1, 501):
        count = 0
        for i in auntSue.keys():
            try:
                if sues[n][i] == auntSue[i]:
                    count += 1
            except KeyError:
                continue
        if count == 3:
            print(n)

def DaySixteen2():

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 16 Input.txt'
    with open(file, 'r') as f:
        lines = f.readlines()

    sues = {}
    for line in lines:
        l = line.split()
        sues[int(l[1][:-1])] = {
            l[2][:-1]:int(l[3][:-1]),
            l[4][:-1]:int(l[5][:-1]),
            l[6][:-1]:int(l[7])
            }

    auntSue = {x.split()[0][:-1]:int(x.split()[1]) for x in '''children: 3
    cats: 7
    samoyeds: 2
    pomeranians: 3
    akitas: 0
    vizslas: 0
    goldfish: 5
    trees: 3
    cars: 2
    perfumes: 1'''.split('\n')}

    
    for n in range(1, 501):
        count = 0
        for i in auntSue.keys():
            try:
                if i == 'cats' or i == 'trees':
                    if sues[n][i] > auntSue[i]:
                        count += 1
                elif i == 'goldfish' or i == 'pomeranians':
                    if sues[n][i] < auntSue[i]:
                        count += 1
                else:
                    if sues[n][i] == auntSue[i]:
                        count += 1
            except KeyError:
                continue
        if count == 3:
            print(n)


def daySeventeen():

    from itertools import combinations

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 17 Input.txt'
    with open(file, 'r') as f:
        containers = sorted([int(line.strip()) for line in f.readlines()])

    def limit(conts):
        total = 0
        count = 0
        for c in conts:
            total += c
            count += 1
            if total >= 150:
                return count

    most = limit(containers)
    least = limit(containers[::-1])

    combos = 0
    for n in range(least, most + 1):
        for i in combinations(containers, n):
            if sum(i) == 150:
                combos += 1
        print('Combos after checking length {}: {}'.format(n, combos))


def dayEighteen(): # runs day 2. Minor adjustments to my normal game of life code
    
    from random import randint
    from time import sleep, time
    from copy import deepcopy

    # updates the board according to the four rules
    def newCycle(board):
        # create a duplicate of the board to update
        new = deepcopy(board)
        for y in range(boardSize):
            for x in range(boardSize):
                n = countLiveNeighbours(board, x, y)
                # activates cells with three neighbours
                if board[y][x] == '.' and n == 3:
                    new[y][x] = '#'
                # kills over- or underpopulated cells
                elif board[y][x] == '#' and (n < 2 or n > 3):
                    new[y][x] = '.'
        ##### remove the below line for day 18 part 1 (1/2)
        (new[0][0], new[0][boardSize-1], new[boardSize-1][0], new[boardSize-1][boardSize-1]) = ('#','#','#','#')
        return new, board

    # why does this need a deepcopy to work? I thought it would be okay just altering board locally
    def printBoard(display, history):
        for y in range(boardSize):
            for x in range(boardSize):
                if display[y][x] == '#':
                    if history[-1][y][x] == '.':
                        display[y][x] = g['newborn']
                    else:
                        display[y][x] = g['live']
                elif display[y][x] == '.':
                    if history[-1][y][x] == '#':
                        display[y][x] = g['dying']
                    else:
                        display[y][x] = g['dead']
        print('\n'.join([''.join(x) for x in display]) + '\n' + '_'*boardSize)
                    

    # Counts the number of neighbours of a cell that are alive
    def countLiveNeighbours(board, x, y):
        l = [(n, m) for n in [y-1, y, y+1] for m in [x-1, x, x+1] if (n, m) != (y, x)]
        neighbours = []
        for i in l:
            try:
                if i[0] != -1 and i[1] != -1:
                    neighbours.append(board[i[0]][i[1]])
                else:
                    raise IndexError
            except IndexError:
                neighbours.append('.')
        return neighbours.count('#')
        

    # checks to see if the board is in an oscillating state 
    def checkOscillation(history, board):
        oscillationRange = 10
        # limits the length of history to the maximum length the oscillator check will look at
        while len(history) > 2*oscillationRange:
            del history[0]
        for i in range(1, oscillationRange):
            if len(history) < 2*i:
                break
            elif board == history[-i] == history[-2*i]:
                return 0

        
    ### SETTINGS ###

    maxGenerations = 100 # max number of generations that the game will run for (first 2 gens will not display)
    boardSize = 100 # length of each side of the board (board is a square)
    maxPopulation = (boardSize**2)//1.25 # max number of initial live cells (default 80% of board)
    minPopulation = (boardSize**2)//5 # minimum number of initial live cells (default 20% of board)
    sleepTime = 0 # time in seconds between each update of the board, normally runs ~0.06s/cycle
    graphics = g = {'live':'#', 'dead':'.','newborn':'#', 'dying':'.'} # characters used for each cell state

    ### INITIALISATIONS ###

    # initialise the board to a blank grid
    board = [list(' '*boardSize) for x in range(boardSize)] # board as a list of lists, can use [y][x] as a co-ordinate ref

    # populate the board with a random number of live cells in random positions
    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 18 Input.txt'
    with open(file, 'r') as f:
        lines = f.readlines()

    for i in range(len(lines)):
        board[i] = list(lines[i])

    ###### remove the below line for day 18 part 1 (2/2)
    (board[0][0], board[0][boardSize-1], board[boardSize-1][0], board[boardSize-1][boardSize-1]) = ('#','#','#','#')
    #print('\n'.join([''.join(x) for x in board]))

    '''
    # oscillator test
    for f in range(3):
        board[2][f] = 'X'
    '''
    # initialise the count of generations, and the history, which is used to detect oscillators  
    generations = 0
    history = []
    genTimes = []

    ### MAIN LOOP ###
    startTime = time()
    while generations < maxGenerations:
    #    if generations > 1:
    #        genTimes.append(time())
    #        printBoard(deepcopy(board), history)
        board, oldBoard = newCycle(board)
        if board == oldBoard:
            print('Static at generation %s' % (generations - 1))
            break
        history.append(oldBoard)
        if checkOscillation(history, board) == 0:
            print('Oscillator reached at generation %s' % (generations - 1))
            break
        sleep(sleepTime)
        generations += 1

    print(''.join([''.join(x) for x in board]).count('#'))
    runTime = str(generations/(time() - startTime))
    print(runTime[:runTime.find('.') + 3] + ' generations/second')



def DayNineteen1():

    import re

    el = re.compile('[A-Z]{1}[a-z]*')

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 19 Input.txt'
    with open(file, 'r') as f:
        lines = f.readlines()

    molecule = lines[-1].strip()

    exchanges = [(line.split()[0], line.split()[2]) for line in lines[:-2]]

    elements = set([x[0] for x in exchanges] + re.findall(el, molecule) + re.findall(el, ''.join([x[1] for x in exchanges])))

    molecule = re.findall(el, molecule)

    indistincts = []
    for i in range(len(molecule)):
        for exchange in exchanges:
            if molecule[i] == exchange[0]:
                copy = molecule[:]
                copy[i] = exchange[1]
                indistincts.append(''.join(copy))

    distincts = []

    for i in indistincts:
        if i not in distincts:
            distincts.append(i)

    print('distinct mols: {}'.format(len(distincts)))
    print('using set(): {}'.format(len(set(indistincts))))


def dayNineteen2():

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 19 Input.txt'
    with open(file, 'r') as f:
        lines = f.readlines()

    mol = lines[-1].strip()

    exchanges = {line.split()[2]:line.split()[0] for line in lines[:-2]}

    order = sorted([(len(k) - len(exchanges[k]), k) for k in exchanges])[::-1]
    
    count = 0

    while mol != 'e':
        for x in order:
            pos = mol.find(x[1])
            if pos != -1:
                mol = mol[:pos] + exchanges[x[1]] + mol[pos + len(x[1]):]
                print(len(mol))
                count += 1
                if len(mol) == 23:
                    print(mol)
                    break
                break
            else:
                continue

    print(count)
            
                   

def dayTwenty1():

    def factors(n):    
        return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

    import time
    from functools import reduce

    start = time.time()

    p = 0
    houseNo = 1
    jump = 100000
    target = 29000000
    most = 0
    check = houseNo + 1

    '''
    while True:
        if p < target:
            p = sum([x*10 for x in range(1, houseNo + 1) if houseNo % x == 0])
            houseNo += jump
        elif p > target:
            if sum([x*10 for x in range(1, houseNo) if (houseNo - 1) % x == 0]) < target:
                break
            p = sum([x*10 for x in range(1, houseNo + 1) if houseNo % x == 0])
            houseNo += jump
            jump = int(max(jump/10, jump/abs(jump))*-1)
            print('flipped at {}'.format(houseNo))
    '''

    while p <= 29000000:
#        if houseNo % 6 != 0:
#            houseNo += 1
#            continue
# this is my original code, which was too slow. The factors(n) above was nicked off stack overflow
#        p = sum([x*10 for x in range(1, int((houseNo + 2)/2)) if houseNo % x == 0]) + houseNo*10
        p = sum(factors(houseNo))*10
        most = max(p, most)
        if True: #houseNo >= check:
            print('At house {}, presents: {}, max presents: {}, time taken: {}s'.format(houseNo, p, most, str(time.time() - start)[:6]))
            start = time.time()
            check += 1
        houseNo += 1

    print(houseNo)




def dayTwenty2():

    def factors(n):
        l = [[i, n//i] for i in range(max(1, int(n/50)), int(n**0.5) + 1) if n % i == 0]
        l.append([houseNo])
        return set(reduce(list.__add__, l))
        try:
            return set(reduce(list.__add__,
                          ))
        except TypeError:
            return [houseNo]

    import time
    from functools import reduce

    start = time.time()

    p = 0
    houseNo = 1
    jump = 100000
    target = 29000000
    most = 0
    check = houseNo + 10000

    while p <= target:
        p = sum((x*11 for x in range(1, int((houseNo + 2)/2)) if houseNo % x == 0)) + houseNo*11
#        p = sum(factors(houseNo))*11 
        most = max(p, most)
        if houseNo >= check:
            print('At house {}, presents: {}, max presents: {}, time taken: {}s'.format(houseNo, p, most, str(time.time() - start)[:6]))
            start = time.time()
            check += 10000
        houseNo += 1

    print(houseNo - 1)

# the below is a more efficient version based on the reddit solutions (mine didn't work)

def dayTwenty2():

    import time
    start = time.time()

    houses = [0 for i in range(1, 1000000)]

    for n in range(1, 1000000):
        if n % 10000 == 0:
            print('At elf {}, time taken: {}s'.format(n, str(time.time() - start)[:5]))
            start = time.time()
        jumps = 0
        pos = n
        while jumps < 50:
            try:
                houses[pos - 1] += 11*n
                pos += n
                jumps += 1
            except IndexError:
                break


    for h in houses:
        if h >= 29000000:
            print(houses.index(h) + 1)
            break

    for i in range(10):
        print(houses[i])

    print(max(houses))
            

    

def dayTwentyOne1():

    from itertools import combinations

    shop = '''Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3'''.split('\n')
    
    boss = {'damage':9,
            'armour':2}
    me = {}

    weapons = [line.split() for line in shop[1:6]]
    armour = [line.split() for line in shop[8:13]]
    rings = [line.split() for line in shop[15:22]]
    # note that rings have an additional because of the space in the name

    # both are named the same so that combinations won't look at duplicates, one with each blank
    # ...actually, combinations doesn't work like that. Oh well.
    blanks = [['blank', '0', '0', '0', '0'], ['blank', '0', '0', '0', '0']]

    armour.append(blanks[0])
    rings.extend(blanks)

    ringCombos = combinations(rings, 2)

    def win(weapon, armour, ringCombo):
        #print('Weapon: {}'.format(weapon))
        #print('Armour: {}'.format(armour))
        #print('Rings: {}'.format(ringCombo))
        boss['HP'] = 103
        me['HP'] = 100
        me['armour'] = int(armour[3]) + int(ringCombo[0][4]) + int(ringCombo[1][4])
        me['damage'] = int(weapon[2]) + int(ringCombo[0][3]) + int(ringCombo[1][3])
        turn = 1
        #print('Me:   {}'.format(me))
        #print('Boss: {}'.format(boss))
        while True:
            if turn % 2 == 1:
                boss['HP'] -= max(me['damage'] - boss['armour'], 1)
                #print('Boss: {}'.format(boss))
                if boss['HP'] <= 0:
                    return True
            else:
                me['HP'] -= max(boss['damage'] - me['armour'], 1)
                #print('Me:   {}'.format(me))
                if me['HP'] <= 0:
                    return False
            turn += 1

            
    winners = []
    def netOnBoss(w, a, i):
        return int(w[2]) + int(i[0][3]) + int(i[1][3]) - 2
    def netOnMe(w, a, i):
        return 9 - int(a[3]) - int(i[0][4]) - int(i[1][4])

    
    
    
    for w in weapons:
        #print('WEAPON'*10)
        #print(w)
        for a in armour:
            #print('ARMOUR'*10)
            #print(a)
            for i in combinations(rings, 2):
                #print('RINGS'*10)
                #print(i)
                #print('yuppo')
                #print('Dmg to boss: {}, dmg to me: {}, win = {}'.format(netOnBoss(w,a,i), netOnMe(w,a,i), netOnBoss(w,a,i) > netOnMe(w,a,i)))
                
                
                #print()
                #print('Cost = {}'.format(int(w[1]) + int(a[1]) + int(i[0][2]) + int(i[1][2])))
                if win(w, a, i):
                    gold = int(w[1]) + int(a[1]) + int(i[0][2]) + int(i[1][2])
                    winners.append(gold)
                    #print('#'*20)
                    #print(winners)

    print(min(winners))
            

def dayTwentyOne2():

    from itertools import combinations

    shop = '''Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3'''.split('\n')
    
    boss = {'damage':9,
            'armour':2}
    me = {}

    weapons = [line.split() for line in shop[1:6]]
    armour = [line.split() for line in shop[8:13]]
    rings = [line.split() for line in shop[15:22]]
    # note that rings have an additional because of the space in the name

    # both are named the same so that combinations won't look at duplicates, one with each blank
    # ...actually, combinations doesn't work like that. Oh well.
    blanks = [['blank', '0', '0', '0', '0'], ['blank', '0', '0', '0', '0']]

    armour.append(blanks[0])
    rings.extend(blanks)

    ringCombos = combinations(rings, 2)

    def lose(weapon, armour, ringCombo):
        #print('Weapon: {}'.format(weapon))
        #print('Armour: {}'.format(armour))
        #print('Rings: {}'.format(ringCombo))
        boss['HP'] = 103
        me['HP'] = 100
        me['armour'] = int(armour[3]) + int(ringCombo[0][4]) + int(ringCombo[1][4])
        me['damage'] = int(weapon[2]) + int(ringCombo[0][3]) + int(ringCombo[1][3])
        turn = 1
        #print('Me:   {}'.format(me))
        #print('Boss: {}'.format(boss))
        while True:
            if turn % 2 == 1:
                boss['HP'] -= max(me['damage'] - boss['armour'], 1)
                #print('Boss: {}'.format(boss))
                if boss['HP'] <= 0:
                    return False
            else:
                me['HP'] -= max(boss['damage'] - me['armour'], 1)
                #print('Me:   {}'.format(me))
                if me['HP'] <= 0:
                    return True
            turn += 1

            
    losers = []
    def netOnBoss(w, a, i):
        return int(w[2]) + int(i[0][3]) + int(i[1][3]) - 2
    def netOnMe(w, a, i):
        return 9 - int(a[3]) - int(i[0][4]) - int(i[1][4])

    '''
    cheapwin = [int(w[1]) + int(a[1]) + int(i[0][2]) + int(i[1][2]) for w in weapons for a in armour for i in combinations(rings, 2) if netOnBoss(w,a,i)>=netOnMe(w,a,i)]
    print(cheapwin)
    print(min(cheapwin))
    '''
    
    for w in weapons:
        #print('WEAPON'*10)
        #print(w)
        for a in armour:
            #print('ARMOUR'*10)
            #print(a)
            for i in combinations(rings, 2):
                #print('RINGS'*10)
                #print(i)
                #print('yuppo')
                #print('Dmg to boss: {}, dmg to me: {}, win = {}'.format(netOnBoss(w,a,i), netOnMe(w,a,i), netOnBoss(w,a,i) > netOnMe(w,a,i)))
                
                
                #print()
                #print('Cost = {}'.format(int(w[1]) + int(a[1]) + int(i[0][2]) + int(i[1][2])))
                if lose(w, a, i):
                    gold = int(w[1]) + int(a[1]) + int(i[0][2]) + int(i[1][2])
                    losers.append(gold)
                    #print('#'*20)
                    #print(winners)

    print(max(losers))
            
def dayTwentyOneShort():

    shop = '''Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3'''.split('\n')

    from itertools import combinations

    weapons = [line.split() for line in shop[1:6]]
    armour = [line.split() for line in shop[8:13]]
    rings = [line.split() for line in shop[15:]]
    armour.append([0 for i in range(4)]) # blank entry to count as none chosen
    rings.extend([[0 for i in range(5)] for j in range(2)]) # same as above

    def db(w, a, i): # damage per round to boss
        return max(1, int(w[2]) + int(i[0][3]) + int(i[1][3]) - 2)
    def dm(w, a, i): # damage per round to me
        return max(1, 9 - int(a[3]) - int(i[0][4]) - int(i[1][4]))


    print(min([int(w[1]) + int(a[1]) + int(i[0][2]) + int(i[1][2])
               for w in weapons
               for a in armour
               for i in combinations(rings, 2)
               if (102//db(w,a,i)) <= (99//dm(w,a,i))]))


def dayTwentyTwo1():

    import random
    import itertools

    spells = {'mm':53,
              'drain':73,
              'shield':113,
              'poison':173,
              'recharge':229}

    
#    gen = list(spells.keys())
#    for n in range(25):
#        gen.extend(gen)

#    print(len(gen))

#    strats = itertools.combinations(gen, 25)



    
    def fight(mode):
        boss = 51
        me = 50
        mana = 500
        spent = 0
        armour = 0
        poison = 0
        recharge = 0
        
        for turn in range(50):

            #print('-------- TURN {} ----------'.format(turn))
            
            # break as soon as it's impossible for it to be the best option
            if spent > optimum:
                return False, 0
            
            if poison > 0:
                boss -= 3
                poison -= 1
                #print("Boss takes 3 poison damage, poison's count is {}".format(poison))
                if boss <= 0:
                    return True, spent
            if recharge > 0:
                mana += 101
                recharge -= 1
                #print("You regain 101 mana, recharge's count is {}".format(recharge))
            armour = max(0, armour - 1)
            if turn % 2 == 0: # player's turn
                #print("Player's turn")
                if mode == 'hard':
                    me -= 1
                    #print("Player took 1 damage for hard mode")
                    if me <= 0:
                        return False, 0
                while True:
                    spell = random.choice(list(spells.keys()))
#                    try:
#                        spell = seed[-turn//2]
#                    except IndexError:
#                        return False, 0
                    if spell == 113 and armour > 0 or spell == 173 and poison > 0 or spell == 229 and recharge > 0:
                        continue
                    else:
                        break
                #print('Player casts {}'.format(spell))
                cost = spells[spell]
                if spell == 'mm':
                    boss -= 4
                    mana -= cost
                    spent += cost
                    #print("Player casts magic missile for {} mana.\nBoss takes 4 damage, down to {}".format(cost,boss))
                elif spell == 'drain':
                    boss -= 2
                    me += 2
                    mana -= cost
                    spent += cost
                    #print('Player casts drain for {} mana.\nBoss takes 2 damage, down to {}.\nPlayer gains 2 health, up to {}.'.format(cost,boss,me))
                elif spell == 'shield':
                    armour = 6
                    mana -= cost
                    spent += cost
                    #print("Player casts shield for {} mana.".format(cost))
                elif spell == 'poison':
                    poison += 6
                    mana -= cost
                    spent += cost
                    #print('Player casts poison for {} mana.'.format(cost))
                elif spell == 'recharge':
                    recharge += 5
                    mana -= cost
                    spent += cost
                    #print('Player casts recharge for {} mana.'.format(cost))
                    
            else: # boss's turn
                #print("Boss's turn")
                me -= 9
                if armour > 0:
                    me += 7
                    #print('Boss attacks player for 2 damage, down to {}'.format(me))
                #else:
                    #print('Boss attacks player for 9 damage, down to {}'.format(me))
            
            #print('''Boss health: {}
#Player health: {}
#Mana: {}
#Spent: {}
#Spell: {}'''.format(boss, me, mana, spent, spell))

            # check if the fight is over
            if mana <= 0:
                return False, 0
            elif me <= 0:
                return False, 0
            elif boss <= 0:
                return True, spent

    d = {str(n):['mm', 'drain', 'shield', 'poison', 'recharge'][n%5] for n in range(10)}
    #print(d)
    strat = 0

    seed = [d[i] for i in list(str(strat))]
    
    '''
    optimum = 100000
    wins = 0
    for i in range(1000000):
        result = fight('easy')
        # think this is obsolete because of the break in the loop, could just be optimum = result[0]
        if result[0]:
            wins += 1
            optimum = min(optimum, result[1])

    print('Part 1: {}'.format(optimum))
    print('Total wins: {}'.format(wins))
    '''

    optimum = 100000
    wins = 0
    for i in range(1000000):
        result = fight('hard')
        # think this is obsolete because of the break in the loop, could just be optimum = result[0]
        if result[0]:
            wins += 1
            optimum = min(optimum, result[1])
        strat += 1
        if strat % 100000 == 0:
            print('''Strat: {}\nOptimum: {}\nWins: {}'''.format(strat, optimum, wins))

    print('Part 2: {}'.format(optimum))
    print('Total wins: {}'.format(wins))    
        
            


