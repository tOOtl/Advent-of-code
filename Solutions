# Advent of code

def DayOnePuzzleOne():
    instructions = """()(((()))(()()()((((()(((())(()(()((((((()(()(((())))((()(((()))((())(()((()()()()(((())(((((((())))()()(()(()(())(((((()()()((())(((((()()))))()(())(((())(())((((((())())))(()())))()))))()())()())((()()((()()()()(()((((((((()()())((()()(((((()(((())((())(()))()((((()((((((((())()((()())(())((()))())((((()())(((((((((((()()(((((()(()))())(((()(()))())((()(()())())())(()(((())(())())()()(()(()((()))((()))))((((()(((()))))((((()(()(()())())()(((()((((())((((()(((()()(())()()()())((()((((((()((()()))()((()))()(()()((())))(((()(((()))((()((()(()))(((()()(()(()()()))))()()(((()(((())())))))((()(((())()(()(())((()())))((((())))(()(()(()())()((()())))(((()((()(())()()((()((())(()()((())(())()))()))((()(())()))())(((((((()(()()(()(())())))))))(()((((((())((((())((())())(()()))))()(())(()())()())((())(()))))(()))(()((()))()(()((((((()()()()((((((((()(()(())((()()(()()))(())()())()((())))()))()())(((()))(())()(())()))()((()((()(()()())(())()()()((())())))((()()(()()((()(())()()())(((()(()()))))(())))(()(()())()))()()))))))()))))((((((())))())))(()(())())(()())))))(()))()))))))()((()))))()))))(()(()((()())())(()()))))(((())()))())())())(((()(()()))(())()(())(())((((((()()))))((()(()))))))(()))())(((()()(()))()())()()()())))))))))))))(())(()))(()))((()(())(()())(())())(()())(())()()(()())))()()()))(())())()))())())(())((())))))))(())))(())))))()))))((())(()(((()))))(()))()((()(())))(()())(((((()))()())()()))))()))))()))())(()(()()()))()))))))((()))))))))))()((()))((()(())((())()()(()()))()(()))))()()(()))()))(((())))(())()((())(())(()())()())())))))))())))()((())))()))(()))()()))(((((((()))())(()()))(()()(()))()(()((()())()))))))(((()()()())))(())()))()())(()()))()()))))))))(())))()))()()))))))()))()())))()(())(())))))()(())()()(()()))))())((()))))()))))(()(((((()))))))))())))())()(())()()))))(())))())()()())()()())()(()))))()))()))))))))())))((()))()))()))())))()())()()())))())))(()((())()((()))())))))())()(())((())))))))))))())()())(())())())(()))(()))()))())(()(())())()())()()(()))))(()(())))))))(())))())(())))))))())()()(())())())))(())))))()))()(()())()(()))())())))))()()(()))()))))())))))))))()))))()))))))())()())()()))))()())))())))))))))))()()))))()()(((()))()()(())()))))((()))))(()))(())())))(())()))))))(()))()))))(())())))))()))(()())))))))))))))())))))))))()((()())(()())))))))((()))))(())(())))()(()())())))())())(()()()())))()))))))())))))())()()())))))))))))()()(()))))()())()))((()())(()))))()(()))))))))))()())())(((())(()))))())()))()))()))))))()))))))(()))))()))))()(())))(())))(()))())()()(()()))()))(()()))))))))()))(()))())(()()(()(()())()()))()))))))))(())))))((()()(()))())())))))()))())(()())()()))())))()(()()()()))((())())))())()(()()))()))))))))(()))(())))()))))(()(()())(()))))()())())()))()()))())))))))))))())()))))))()))))))))())))))()))))())(()())))(())()))())())))))()()(()()())(()())))()()))(((()))(()()()))))()))))()))))((())))()((((((()()))))))())))))))))))(((()))))))))))))(())())))))())(()))))))(()))((()))())))()(()((()))()))()))))))))))())()))()(()()))))())))())(())()(()))()))())(()))()))))(()()))()()(())))))()))(())(()(()()))(()()())))))(((()))))))()))))))))))))(())(()))))()())())()()((()()))())))))(()))))())))))))()()()))))))))())))()(((()()))(())))))(((())())))))((()))()(()))(()))))(()())))(()))())))))()))))(())(())))()((()))(())())))()()))()))))))))()))(()()()(()()()(()))())(())()())(((()))(())))))))))(((()())))()()))))))))()(())(()))()((((())(())(()())))()))(((())()()()))((()))(()))())())))())))(()))())()())())(()(())())()()()(())))())(())))(())))(())()))()))(()((()))))))))())(()))))))())(()()))()()))()(()(()())))()()(()((()((((((()))(())))()()()))())()))((()()(()))())((()(()(()))(()()))))()())))()))()())))))))()()((()())(())))()))(()))(())(()))())(()(())))()()))))))(((()(((()()))()(()(())())((()()))()))()))()))()(()()()(()))((()())()(())))()()))(((())()()())(())()((()()()()(()(())(()()))()(((((()())))((())))))(()()()))))(((()(())))()))((()((()(())()(()((())))((()())()(()))(((()())()()(()))(())(((()((()())()((())()())(((()()))((()((())(()))(()())(()()()))((()))(())(()((()()())((()))(())))(())(())(())))(()())))(((((()(()(((((()())((((()(()())(())(()()(((())((()(((()()(((()()((((((())))())(()((((((()(()))()))()()((()((()))))()(()()(()((()()))))))(((((()(((((())()()()(())())))))))()))((()()(())))(())(()()()())))))(()((((())))))))()()(((()(()(()(()(()())()()()(((((((((()()())()(()))((()()()()()(((((((()())()((())()))((((((()(()(()(()())(((()(((((((()(((())(((((((((())(())())()))((()(()))(((()()())(())(()(()()(((()(())()))())))(())((((((())(()()())()()(((()(((())(()(((())(((((((()(((((((((()))(())(()(()(()))))((()))()(())())())((()(()((()()))((()()((()(())(())(()((())(((())(((()()()((((((()()(())((((())()))))(())((()(()((())))(((((()(()()())())((())())))((())((()((()()((((((())(((()()(()())())(()(()))(()(()))())())()(((((((()(((()(())()()((())((()(()()((()(()()(((((((((((())((())((((((())((()((((()(()((((()(((((((())()((()))))())()((()((((()(()(((()((()())))(())())(((()(((())((((((()(((((((((()()(())))(()(((((()((((()())))((()((()((()(()()(((())((((((((((((()(((())(()(((((()))(()()(()()()()()()((())(((((((())(((((())))))())()(()()(()(()(((()()(((((())(()((()((()(((()()((()((((())()))()((((())(())))()())(((())(())(()()((()(((()()((((((((((()()(()())())(((((((((())((((()))()()((((())(()((((()(((())())(((((((((((()((((())))(())(()(((()(((()((())(((((()((()()(()(()()((((((()((((()((()(()((()(()((((((()))))()()(((((()((()(()(())()))(())(((((((()((((()())(()((()((()(()))())))(())((()))))(((((((()()()())(()))(()()((()())()((()((()()()(()(()()))(()())(())(((((()(((((((((((()((()(((()(((((((()()((((((()(((((()(()((()(((((())((((((()))((((())((()()((())(((())()(((((()()(((((()((()(()(((((((()(((((()((()((()((())(())((())(()))()()))(()()(()(()()(((((((()(((()(((())()(((((()((((((()())((((())()((()((()(()()())(()))((((()()((((((()((()(()(()((((()((()((())((((((()(()(())((((((()((((((((((()((())()))()(()(()(((((()()()))((())))()(()((((((((((((((()(((()((((()((())((()((()(((()()(()(((()((())(()()())))()(()(()(((((()()(()(()((((()(((((())()(()(()))(((((()()(((()()(())((((((((((((((())((())(((((((((((())()()()(())()(()(()(((((((((())(((()))(()()())(()((((()(())(((((()())(())((((((((())()((((()((((((())(()((()(())(((()((((()))(((((((((()()))((((()(())()()()(())(()((())((()()))()(((())(((((())((((((()()))(((((((((()((((((())))(((((((()((()(()(())))())(()(()))()(((((()())(()))()(()(())(((()))))())()())))(((((()))())()((()(()))))((()()()((((((()))()()((((((((())((()(()(((()(()((())((()())(()((((())(()(((()()()(()(()()))())())((((((((((())())((()))()((())(())(())))())()(()()(())))())(()))(((()(()()(((()(((())))()(((()(())()((((((())()))()))()((((((()(()(((((()())))()))))())()()(((()(((((())((()()(()((()((()(()(()(())))(()()()()((()(())(((()((()))((((()))())(())))())(()))()()()())()))(((()()())()((())))(())(()()()()(()())((()(()()((((())))((()((()(())((()(()((())()(()()(((()())()()())((()))((())(((()()(())))()()))(((()((())()(((((()())(())((())()())())((((((()(()(((((()))(()("""
    print(instructions.count('(') - instructions.count(')'))

def DayOnePuzzleTwo():
    instructions = """()(((()))(()()()((((()(((())(()(()((((((()(()(((())))((()(((()))((())(()((()()()()(((())(((((((())))()()(()(()(())(((((()()()((())(((((()()))))()(())(((())(())((((((())())))(()())))()))))()())()())((()()((()()()()(()((((((((()()())((()()(((((()(((())((())(()))()((((()((((((((())()((()())(())((()))())((((()())(((((((((((()()(((((()(()))())(((()(()))())((()(()())())())(()(((())(())())()()(()(()((()))((()))))((((()(((()))))((((()(()(()())())()(((()((((())((((()(((()()(())()()()())((()((((((()((()()))()((()))()(()()((())))(((()(((()))((()((()(()))(((()()(()(()()()))))()()(((()(((())())))))((()(((())()(()(())((()())))((((())))(()(()(()())()((()())))(((()((()(())()()((()((())(()()((())(())()))()))((()(())()))())(((((((()(()()(()(())())))))))(()((((((())((((())((())())(()()))))()(())(()())()())((())(()))))(()))(()((()))()(()((((((()()()()((((((((()(()(())((()()(()()))(())()())()((())))()))()())(((()))(())()(())()))()((()((()(()()())(())()()()((())())))((()()(()()((()(())()()())(((()(()()))))(())))(()(()())()))()()))))))()))))((((((())))())))(()(())())(()())))))(()))()))))))()((()))))()))))(()(()((()())())(()()))))(((())()))())())())(((()(()()))(())()(())(())((((((()()))))((()(()))))))(()))())(((()()(()))()())()()()())))))))))))))(())(()))(()))((()(())(()())(())())(()())(())()()(()())))()()()))(())())()))())())(())((())))))))(())))(())))))()))))((())(()(((()))))(()))()((()(())))(()())(((((()))()())()()))))()))))()))())(()(()()()))()))))))((()))))))))))()((()))((()(())((())()()(()()))()(()))))()()(()))()))(((())))(())()((())(())(()())()())())))))))())))()((())))()))(()))()()))(((((((()))())(()()))(()()(()))()(()((()())()))))))(((()()()())))(())()))()())(()()))()()))))))))(())))()))()()))))))()))()())))()(())(())))))()(())()()(()()))))())((()))))()))))(()(((((()))))))))())))())()(())()()))))(())))())()()())()()())()(()))))()))()))))))))())))((()))()))()))())))()())()()())))())))(()((())()((()))())))))())()(())((())))))))))))())()())(())())())(()))(()))()))())(()(())())()())()()(()))))(()(())))))))(())))())(())))))))())()()(())())())))(())))))()))()(()())()(()))())())))))()()(()))()))))())))))))))()))))()))))))())()())()()))))()())))())))))))))))()()))))()()(((()))()()(())()))))((()))))(()))(())())))(())()))))))(()))()))))(())())))))()))(()())))))))))))))())))))))))()((()())(()())))))))((()))))(())(())))()(()())())))())())(()()()())))()))))))())))))())()()())))))))))))()()(()))))()())()))((()())(()))))()(()))))))))))()())())(((())(()))))())()))()))()))))))()))))))(()))))()))))()(())))(())))(()))())()()(()()))()))(()()))))))))()))(()))())(()()(()(()())()()))()))))))))(())))))((()()(()))())())))))()))())(()())()()))())))()(()()()()))((())())))())()(()()))()))))))))(()))(())))()))))(()(()())(()))))()())())()))()()))())))))))))))())()))))))()))))))))())))))()))))())(()())))(())()))())())))))()()(()()())(()())))()()))(((()))(()()()))))()))))()))))((())))()((((((()()))))))())))))))))))(((()))))))))))))(())())))))())(()))))))(()))((()))())))()(()((()))()))()))))))))))())()))()(()()))))())))())(())()(()))()))())(()))()))))(()()))()()(())))))()))(())(()(()()))(()()())))))(((()))))))()))))))))))))(())(()))))()())())()()((()()))())))))(()))))())))))))()()()))))))))())))()(((()()))(())))))(((())())))))((()))()(()))(()))))(()())))(()))())))))()))))(())(())))()((()))(())())))()()))()))))))))()))(()()()(()()()(()))())(())()())(((()))(())))))))))(((()())))()()))))))))()(())(()))()((((())(())(()())))()))(((())()()()))((()))(()))())())))())))(()))())()())())(()(())())()()()(())))())(())))(())))(())()))()))(()((()))))))))())(()))))))())(()()))()()))()(()(()())))()()(()((()((((((()))(())))()()()))())()))((()()(()))())((()(()(()))(()()))))()())))()))()())))))))()()((()())(())))()))(()))(())(()))())(()(())))()()))))))(((()(((()()))()(()(())())((()()))()))()))()))()(()()()(()))((()())()(())))()()))(((())()()())(())()((()()()()(()(())(()()))()(((((()())))((())))))(()()()))))(((()(())))()))((()((()(())()(()((())))((()())()(()))(((()())()()(()))(())(((()((()())()((())()())(((()()))((()((())(()))(()())(()()()))((()))(())(()((()()())((()))(())))(())(())(())))(()())))(((((()(()(((((()())((((()(()())(())(()()(((())((()(((()()(((()()((((((())))())(()((((((()(()))()))()()((()((()))))()(()()(()((()()))))))(((((()(((((())()()()(())())))))))()))((()()(())))(())(()()()())))))(()((((())))))))()()(((()(()(()(()(()())()()()(((((((((()()())()(()))((()()()()()(((((((()())()((())()))((((((()(()(()(()())(((()(((((((()(((())(((((((((())(())())()))((()(()))(((()()())(())(()(()()(((()(())()))())))(())((((((())(()()())()()(((()(((())(()(((())(((((((()(((((((((()))(())(()(()(()))))((()))()(())())())((()(()((()()))((()()((()(())(())(()((())(((())(((()()()((((((()()(())((((())()))))(())((()(()((())))(((((()(()()())())((())())))((())((()((()()((((((())(((()()(()())())(()(()))(()(()))())())()(((((((()(((()(())()()((())((()(()()((()(()()(((((((((((())((())((((((())((()((((()(()((((()(((((((())()((()))))())()((()((((()(()(((()((()())))(())())(((()(((())((((((()(((((((((()()(())))(()(((((()((((()())))((()((()((()(()()(((())((((((((((((()(((())(()(((((()))(()()(()()()()()()((())(((((((())(((((())))))())()(()()(()(()(((()()(((((())(()((()((()(((()()((()((((())()))()((((())(())))()())(((())(())(()()((()(((()()((((((((((()()(()())())(((((((((())((((()))()()((((())(()((((()(((())())(((((((((((()((((())))(())(()(((()(((()((())(((((()((()()(()(()()((((((()((((()((()(()((()(()((((((()))))()()(((((()((()(()(())()))(())(((((((()((((()())(()((()((()(()))())))(())((()))))(((((((()()()())(()))(()()((()())()((()((()()()(()(()()))(()())(())(((((()(((((((((((()((()(((()(((((((()()((((((()(((((()(()((()(((((())((((((()))((((())((()()((())(((())()(((((()()(((((()((()(()(((((((()(((((()((()((()((())(())((())(()))()()))(()()(()(()()(((((((()(((()(((())()(((((()((((((()())((((())()((()((()(()()())(()))((((()()((((((()((()(()(()((((()((()((())((((((()(()(())((((((()((((((((((()((())()))()(()(()(((((()()()))((())))()(()((((((((((((((()(((()((((()((())((()((()(((()()(()(((()((())(()()())))()(()(()(((((()()(()(()((((()(((((())()(()(()))(((((()()(((()()(())((((((((((((((())((())(((((((((((())()()()(())()(()(()(((((((((())(((()))(()()())(()((((()(())(((((()())(())((((((((())()((((()((((((())(()((()(())(((()((((()))(((((((((()()))((((()(())()()()(())(()((())((()()))()(((())(((((())((((((()()))(((((((((()((((((())))(((((((()((()(()(())))())(()(()))()(((((()())(()))()(()(())(((()))))())()())))(((((()))())()((()(()))))((()()()((((((()))()()((((((((())((()(()(((()(()((())((()())(()((((())(()(((()()()(()(()()))())())((((((((((())())((()))()((())(())(())))())()(()()(())))())(()))(((()(()()(((()(((())))()(((()(())()((((((())()))()))()((((((()(()(((((()())))()))))())()()(((()(((((())((()()(()((()((()(()(()(())))(()()()()((()(())(((()((()))((((()))())(())))())(()))()()()())()))(((()()())()((())))(())(()()()()(()())((()(()()((((())))((()((()(())((()(()((())()(()()(((()())()()())((()))((())(((()()(())))()()))(((()((())()(((((()())(())((())()())())((((((()(()(((((()))(()("""
    floor = 0
    count = 0
    for i in instructions:
        if i == '(':
            floor += 1
        elif i == ')':
            floor -= 1 
        count += 1
        if floor == -1:
            print(count)  

def DayTwoPuzzleOne():

    def calculateArea(line):
        lengths = line.split('x')
        for i in range(len(lengths)):
            lengths[i] = int(lengths[i])
        end = lengths[0]*lengths[1]
        top = lengths[0]*lengths[2]
        side = lengths[1]*lengths[2]
        slack = min(end, top, side)
        return 2*sum([end, top, side]) + slack
    
    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 2 Puzzle 1 input.txt', 'r') as f:
        total = 0
        for line in f.readlines():
            total += calculateArea(line)
        print(total)

def DayTwoPuzzleTwo():

    def getRibbonLength(line):
        lengths = line.split('x')
        for i in range(len(lengths)):
            lengths[i] = int(lengths[i])
        
        lengths = sorted(lengths)
        return (2*lengths[0] + 2*lengths[1]) + (lengths[0]*lengths[1]*lengths[2])

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 2 Puzzle 1 input.txt', 'r') as f:
        total = 0
        for line in f.readlines():
            total += getRibbonLength(line)
        print(total)

def DayThree1():

    def maxDisplacement(instructions, direction, opposite):
        displacement, maxDirection, maxOpposite = 0, 0, 0
        for i in instructions:
            if i == direction:
                displacement += 1
            elif i == opposite:
                displacement -= 1
            if displacement > maxDirection:
                maxDirection = displacement
            if displacement < maxOpposite:
                maxOpposite = displacement
        return maxDirection, abs(maxOpposite)        

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 3 Puzzle 1 input.txt', 'r') as f:
        instructions = []
        for line in f.readlines():
            for i in line:
                if i in '^<>v':
                    instructions.append(i)

    maxNorth, maxSouth = maxDisplacement(instructions, '^', 'v')
    maxWest, maxEast = maxDisplacement(instructions, '<', '>')
    print((maxNorth, maxEast, maxSouth, maxWest))

    grid = list([0 for house in range(maxWest + maxEast + 1)] for row in range((maxNorth + maxSouth + 1)))
    print(len(grid))
    print(len(grid[0]))

    x = maxWest - 1
    y = maxNorth - 1

    go = {'x':{'>':1, '<':-1}, 'y':{'^':1, 'v':-1}}

    for item in instructions:
        grid[y][x] += 1
        if item in '<>':
            x += go['x'][item]
        else:
            y += go['y'][item]
    grid[y][x] += 1

    housesHit = 0

    for row in grid:
        for house in row:
            if house != 0:
                housesHit += 1

    print(housesHit)
        

def DayThree2():

    def maxDisplacement(instructions, direction, opposite):
        displacement, maxDirection, maxOpposite = 0, 0, 0
        for i in instructions:
            if i == direction:
                displacement += 1
            elif i == opposite:
                displacement -= 1
            if displacement > maxDirection:
                maxDirection = displacement
            if displacement < maxOpposite:
                maxOpposite = displacement
        return maxDirection, abs(maxOpposite)

    def santaJourney(instructions, grid):
        x = maxWest - 1
        y = maxNorth - 1

        go = {'x':{'>':1, '<':-1}, 'y':{'^':1, 'v':-1}}

        for item in instructions:
            grid[y][x] += 1
            if item in '<>':
                x += go['x'][item]
            else:
                y += go['y'][item]
        grid[y][x] += 1

        return grid
        

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 3 Puzzle 1 input.txt', 'r') as f:
        instructions = []
        roboInstructions = []
        count = 0
        for line in f.readlines():
            for i in line:
                count += 1
                if i in '^<>v':
                    if count % 2 == 1:
                        instructions.append(i)
                    else:
                        roboInstructions.append(i)

    n1, s1 = maxDisplacement(instructions, '^', 'v')
    w1, e1 = maxDisplacement(instructions, '<', '>')
    n2, s2 = maxDisplacement(roboInstructions, '^', 'v')
    w2, e2 = maxDisplacement(roboInstructions, '<', '>')

    maxNorth, maxEast, maxSouth, maxWest = max(n1,n2), max(e1,e2), max(s1,s2), max(w1,w2)

    grid = list([0 for house in range(maxWest + maxEast + 1)] for row in range((maxNorth + maxSouth + 1)))
                        
    grid = santaJourney(instructions, grid)
    grid = santaJourney(roboInstructions, grid)

    housesHit = 0

    for row in grid:
        for house in row:
            if house != 0:
                housesHit += 1

    print(housesHit)
    

def DayFour():

    from hashlib import md5

    key = b'bgvyzdsv'
    digits = 0

    while True:
        digits += 1
        if md5(b'%s%s' % (key, bytes(str(digits), 'utf-8'))).hexdigest()[:6] == '000000': # remove one zero in this string and change index to [:5] for puzzle one
            print(digits)
            break
        
def DayFive1():

    nice = 0

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 5 Input.txt', 'r') as f:
        for line in f.readlines():
            if len([x for x in line if x in 'aeiou']) > 2 and len([line[x-1:x+1] for x in range(1, len(line)) if line[x] == line[x-1]]) > 0 and len([line[x-1:x+1] for x in range(1, len(line)) if line[x-1:x+1] in ['ab', 'cd', 'pq', 'xy']]) == 0:
                nice += 1
                
        print(nice)

def DayFive2():

    nice = 0

    with open('/Users/Zak/Documents/Programs/Website Challenges/Day 5 Input.txt', 'r') as f:
        for line in f.readlines():
            if len([line[x-2:x] for x in range(2, len(line)) if line[x-2:x] in line[x:]]) > 0 and len([line[x:x+3] for x in range(len(line) - 2) if line[x] == line[x+2]]) > 0:
                nice += 1
                
        print(nice)
        
def DaySix1():

    def lights(grid, instruction, l, r, u, d):
        for y in range(u, d + 1):
            for x in range(l, r + 1):
                if instruction == 'on':
                    grid[y][x] = 'X'
                elif instruction == 'off':
                    grid[y][x] = ' '
                elif instruction == 'oggle':
                    if grid[y][x] == 'X':
                        grid[y][x] = ' '
                    elif grid[y][x] == ' ':
                        grid[y][x] = 'X'

    grid = [[' ' for x in range(1000)] for y in range(1000)]
    total = 0

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 6 Input.txt'
    with open(file, 'r') as f:
        for line in f.readlines():
            line = line.strip('turn \n').split()

            topLeft, bottomRight = line[1].split(','), line[3].split(',')

            l, r, u, d = int(topLeft[0]), int(bottomRight[0]), int(topLeft[1]), int(bottomRight[1])

            lights(grid, line[0], l, r, u, d)

        for row in grid:
            total += row.count('X')

        print(total)

def DaySix2():

    def lights(grid, instruction, l, r, u, d):
        for y in range(u, d + 1):
            for x in range(l, r + 1):
                if instruction == 'on':
                    grid[y][x] += 1
                elif instruction == 'off' and grid[y][x] != 0:
                    grid[y][x] -= 1
                elif instruction == 'oggle':
                    grid[y][x] += 2

    grid = [[0 for x in range(1000)] for y in range(1000)]
    total = 0

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 6 Input.txt'
    with open(file, 'r') as f:
        for line in f.readlines():
            line = line.strip('turn \n').split()

            topLeft, bottomRight = line[1].split(','), line[3].split(',')

            l, r, u, d = int(topLeft[0]), int(bottomRight[0]), int(topLeft[1]), int(bottomRight[1])

            lights(grid, line[0], l, r, u, d)

        for row in grid:
            total += sum(row)

        print(total) 

                

def DaySeven1():

    def evalWire(wire, depth):
        print(wire)
        print(depth)
        '''
        operation = wires[wire]
        print(operation)'''
        try:
            int(wire)
##            print('evaluated %s' % int(wire))
            depth -= 1
            return int(wire)
            '''
#            print('evaluated %s' % wire)
            if len(operation) == 1:
                return int(operation[0]) # once it gets back to a number, return that as an int
            else:
                raise ValueError'''
        
        except ValueError:
            operation = wires[wire]
##            print('%s %s' % (operation, wire))
            if len(operation) == 1:
                return evalWire(operation[0], depth + 1) # if it's a wire name only (no operation) or a number, evaluate the input and return it
            elif len(operation) == 2:
                '''if len(bin(evalWire(operation[1]))) < 18:
                    string = bin(evalWire(operation[1]))
                    print(string)
                    string = string[2:].zfill(16)
                    print(string)
                    thing = ''.join([['1','0'][int(x)] for x in string])
                    print(thing)'''
#                print(bin(evalWire(operation[1])))
#                print(bin(65535 - evalWire(operation[1])))
                return 65535 - evalWire(operation[1], depth+1) # if it's a NOT gate, evaluate the input and return the NOT of it NEED THIS TO BE 16BIT
            else:
                if 'AND' in operation:
                    return evalWire(operation[0], depth+1) & evalWire(operation[2], depth+1) # if it's an AND gate, evaluate the inputs and return their AND
                elif 'OR' in operation:
                    return evalWire(operation[0], depth+1) | evalWire(operation[2], depth+1) # if it's an OR gate, evaluate the inputs and return their OR
                elif 'LSHIFT' in operation:
                    return evalWire(operation[0], depth+1) << int(operation[2]) # if it's an LSHIFT, evaluate the input and shift it the appropriate number left
                elif 'RSHIFT' in operation:
                    return evalWire(operation[0], depth+1) >> int(operation[2]) # if it's an RSHIFT, evaluate the input and shift it the appropriate number right

    def evalWire(wire, depth):

        depth += 1

        print(depth)

        if type(wires[wire]) == int:
            return wires[wire]

        try:
            print(int(wire))
            depth -= 1
            return int(wire)
        
        except ValueError:
            operation = wires[wire]
            if len(operation) == 1: # number or single wire case
                wires[wire] = evalWire(operation[0], depth)
                return evalWire(operation[0], depth)
            elif len(operation) == 2: # NOT case
                return 65535 - evalWire(operation[1], depth)
            else:
                if 'AND' in operation: # AND case
                    return evalWire(operation[0], depth) & evalWire(operation[2], depth)
                elif 'OR' in operation: # OR case
                    return evalWire(operation[0], depth) | evalWire(operation[2], depth)
                elif 'LSHIFT' in operation: # LSHIFT case
                    return evalWire(operation[0], depth) << int(operation[2])
                elif 'RSHIFT' in operation: # RSHIFT case
                    return evalWire(operation[0], depth) >> int(operation[2])
            

    wires = {}
    

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 7 Input.txt'
    with open(file, 'r') as f:
        for line in f.readlines():
            wires[line.split()[-1]] = line.split()[:-2]

#    for i in wires:
#        print(wires[i])
    
    print(evalWire('a', 0))
'''
    wires = {'x':['123'], 'y': ['456'], 'd': ['x', 'AND', 'y'], 'e': ['x', 'OR', 'y'], 'f':['x', 'LSHIFT', '2'], 'g':['y', 'RSHIFT', '2'], 'h': ['NOT', 'x'], 'i': ['NOT', 'y']}
        
    for i in list('xydefghi'):
        print('%s equals %s' % (i, evalWire(i)))
'''
            
            
def DaySeven1():

    def evalWire(operation):
        
        try:
            if len(operation) == 1:
                return wires[operation[0]]
            elif len(operation) == 2:
                return 65535 - wires[operation[1]]
            else:
                if 'AND' in operation:
                    return wires[operation[0]] & wires[operation[2]]
                elif 'OR' in operation:
                    return wires[operation[0]] | wires[operation[2]]
                elif 'RSHIFT' in operation:
                    return wires[operation[0]] >> int(operation[2])
                elif 'LSHIFT' in operation:
                    return wires[operation[0]] << int(operation[2])
            
        except TypeError:
            return None

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 7 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()

    wires = {line.split()[-1]:None for line in lines}
    for line in lines:
        for thing in line.split():
            if thing not in ['AND','OR','NOT','LSHIFT','RSHIFT', '->'] and thing not in wires.keys():
                wires[thing] = int(thing)
    while None in wires.values():
        for line in lines:
            operation = line.split()[:-2]
            wires[line.split()[-1]] = evalWire(operation)

    print(wires['a'])


def DaySeven2():

    def evalWire(operation):
        
        try:
            if len(operation) == 1:
                return wires[operation[0]]
            elif len(operation) == 2:
                return 65535 - wires[operation[1]]
            else:
                if 'AND' in operation:
                    return wires[operation[0]] & wires[operation[2]]
                elif 'OR' in operation:
                    return wires[operation[0]] | wires[operation[2]]
                elif 'RSHIFT' in operation:
                    return wires[operation[0]] >> int(operation[2])
                elif 'LSHIFT' in operation:
                    return wires[operation[0]] << int(operation[2])
            
        except TypeError:
            return None

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 7 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()

    wires = {line.split()[-1]:None for line in lines}

    for i in range(len(lines)):
        if lines[i].split()[-1] == 'b':
            lines[i] = '46065 -> b\n'
            
    for line in lines:
        for thing in line.split():
            if thing not in ['AND','OR','NOT','LSHIFT','RSHIFT', '->'] and thing not in wires.keys():
                wires[thing] = int(thing)
    while None in wires.values():
        for line in lines:
            operation = line.split()[:-2]
            wires[line.split()[-1]] = evalWire(operation)

    print(wires['a'])




def DayEight1():

    import re

    an = re.compile('\w')
    dq = re.compile(r'\\\"')
    bs = re.compile(r'\\\\')
    uc = re.compile(r'\\x[0123456789abcdef]{2,2}')

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 8 Input.txt'

    with open(file, 'r') as f:
        lines = f.readlines()
#        lines = [f.readline() for i in range(20)]

    codeTotal = 0
    memTotal = 0

    for line in lines:
        '''
        print('line:')
        print(line)
        print(len(line))

        print('alphanumeric:')
        print(an.findall(line))
        print(len(an.findall(line)))

        print('double quotes:')
        print(dq.findall(line))
        print(len(dq.findall(line)))

        print('backslashes:')
        print(bs.findall(line))
        print(len(bs.findall(line)))
        

        if len(line) - 1 != len(an.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line)) + len(uc.findall(line)) + 2:
            print(line)
            print(len(an.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line)) + len(uc.findall(line)) + 2)
            print(bs.findall(line))
            print(dq.findall(line))
        '''
        codeTotal += len(line) - 1
        # the codeTotal below is getting the wrong answer for lines that end in \\, because it counts as
        # both a backslash and an escaped quote. stripping the line first should help.
#        codeTotal += len(an.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line)) + len(uc.findall(line)) + 2

#        print('code total:')
#        print(len(an.findall(line)) + 2*len(dq.findall(line)) + 2*len(bs.findall(line)) + len(uc.findall(line)) + 2)

        line = line.strip('\n"')
        '''
        print('unicode:')
        print(uc.findall(line))
        print(len(uc.findall(line)))

        print('len(line) after strip:')
        print(len(line))
        '''
        memTotal += len(line) - 3*len(uc.findall(line)) - len(dq.findall(line)) - len(bs.findall(line))
#        print('mem total:')
#        print(len(line) - 3*len(uc.findall(line)) - len(dq.findall(line)) - len(bs.findall(line)))
        
#        print('-'*20)

    print(codeTotal - memTotal)

DayEight1()
        
        


def DayNine1():

    def trimRoutes(routes, visited):
        new = []
        for route in routes:
            if route[1] in visited or route[2] in visited:
                continue
            else:
                new.append(route)               
        return new
    
    def listForEachPlace(place):
        thisPlace = []
        for route in routes:
            if place in route:
                thisPlace.append([x for x in route if x != place])
        return thisPlace

    file = '/Users/Zak/Documents/Programs/Website Challenges/Day 9 Input.txt'

    with open(file, 'r') as f:
        routes = [sorted([line.split()[-1], line.split()[0], line.split()[2]]) for line in f.readlines()]

    print(routes)
    
    Faerun = listForEachPlace('Faerun')
    Tristram = listForEachPlace('Tristram')
    Tambi = listForEachPlace('Tambi')
    Norrath = listForEachPlace('Norrath')
    Snowdin = listForEachPlace('Snowdin')
    Straylight = listForEachPlace('Straylight')
    AlphaCentauri = listForEachPlace('AlphaCentauri')
    Arbre = listForEachPlace('Arbre')

    destinations = [Faerun, Tristram, Tambi, Norrath, Snowdin, Straylight, AlphaCentauri, Arbre]
    places = ['Faerun', 'Tristram', 'Tambi', 'Norrath', 'Snowdin', 'Straylight', 'AlphaCentauri', 'Arbre']

    mapping = {x:places[x] for x in range(len(places))}

    journeys = [
        []
        ]
    
    print('%s\n'*8 % (Faerun, Tristram, Tambi, Norrath, Snowdin, Straylight, AlphaCentauri, Arbre))

    shortest = 0
    
    for place in destinations:
        visited = []
        start = place
        for place in places:
            if place == start:
                continue
            
        
        



    
    



    

    

def DayTen1():

    n = [1,1,1,3,1,2,2,1,1,3]

    def cycle(n):

        new = []

        for i in n:
            try:
                if i == new[-1]:
                    new[-2] += 1
                else:
                    raise IndexError           
            except IndexError:
                new.extend([1, i])

        return new

    for x in range(50):
#        print('%s: %s' % (x, n))
        n = cycle(n)

    print(len(n))


def DayEleven1():

    def rule1(passnum):
        for i in range(2, len(passnum)):
            try:
                if passnum[i] == passnum[i-1] + 1 == passnum[i-2] + 2:
                    return True
            except IndexError:
                print('i = {}, passnum = {}'.format(i, passnum))
        return False

    def rule2(passnum):
        for letter in [8, 11, 14]:
            if letter in passnum:
                for i in range(passnum.index(letter) + 1, len(passnum)):
                    passnum[i] = 0
                passnum[passnum.index(letter)] += 1
                return False
        return True

    def rule3(passnum):
        pairs = []
        for i in range(len(passnum) - 1):
            if passnum[i] == passnum[i+1] and passnum[i] not in pairs:
                pairs.append(passnum[i])
        return len(pairs) >= 2        

    def increment(passnum):
        passnum[-1] += 1
        for i in range(len(passnum)):
            if passnum[len(passnum) - (i+1)] == 26:
                passnum[len(passnum) - (i+1)] = 0
                passnum[len(passnum) - (i+2)] += 1
                

    password = 'cqjxjnds'
    alph = 'abcdefghijklmnopqrstuvwxyz'

    passnum = []
    for i in password:
        passnum.append(alph.find(i))

    count = 0
    while not (rule1(passnum) and rule2(passnum) and rule3(passnum)):
        increment(passnum)
        count += 1

    print(''.join([alph[x] for x in passnum]))


        
